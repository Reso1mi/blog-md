---
title:
  Javaå¤šçº¿ç¨‹åŸºç¡€
tags:
  [å¤šçº¿ç¨‹,å¹¶å‘ç¼–ç¨‹]
categories:
	[å¹¶å‘]
cover: http://static.imlgw.top///20190323/oGikrmykzg5w.jpg?imageslim
date: 2019/4/7 12:00
---
## 1.çº¿ç¨‹ä¸è¿›ç¨‹åŒºåˆ«

æ¯ä¸ªæ­£åœ¨ç³»ç»Ÿä¸Šè¿è¡Œçš„ç¨‹åºéƒ½æ˜¯ä¸€ä¸ªè¿›ç¨‹ã€‚æ¯ä¸ªè¿›ç¨‹åŒ…å«ä¸€åˆ°å¤šä¸ªçº¿ç¨‹ã€‚çº¿ç¨‹æ˜¯ä¸€ç»„æŒ‡ä»¤çš„é›†åˆï¼Œæˆ–è€…æ˜¯ç¨‹åºçš„ç‰¹æ®Šæ®µï¼Œå®ƒå¯ä»¥åœ¨ç¨‹åºé‡Œç‹¬ç«‹æ‰§è¡Œã€‚ä¹Ÿå¯ä»¥æŠŠå®ƒç†è§£ä¸ºä»£ç è¿è¡Œçš„ä¸Šä¸‹æ–‡ã€‚æ‰€ä»¥çº¿ç¨‹åŸºæœ¬ä¸Šæ˜¯è½»é‡çº§çš„è¿›ç¨‹ï¼Œå®ƒè´Ÿè´£åœ¨å•ä¸ªç¨‹åºé‡Œæ‰§è¡Œå¤šä»»åŠ¡ã€‚é€šå¸¸ç”±æ“ä½œç³»ç»Ÿè´Ÿè´£å¤šä¸ªçº¿ç¨‹çš„è°ƒåº¦å’Œæ‰§è¡Œã€‚

ä½¿ç”¨çº¿ç¨‹å¯ä»¥æŠŠå æ®æ—¶é—´é•¿çš„ç¨‹åºä¸­çš„ä»»åŠ¡æ”¾åˆ°åå°å»å¤„ç†ï¼Œç¨‹åºçš„è¿è¡Œé€Ÿåº¦å¯èƒ½åŠ å¿«ï¼Œåœ¨ä¸€äº›ç­‰å¾…çš„ä»»åŠ¡å®ç°ä¸Šå¦‚ç”¨æˆ·è¾“å…¥ã€æ–‡ä»¶è¯»å†™å’Œç½‘ç»œæ”¶å‘æ•°æ®ç­‰ï¼Œçº¿ç¨‹å°±æ¯”è¾ƒæœ‰ç”¨äº†ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹å¯ä»¥é‡Šæ”¾ä¸€äº›çè´µçš„èµ„æºå¦‚å†…å­˜å ç”¨ç­‰ç­‰ã€‚

å¦‚æœæœ‰å¤§é‡çš„çº¿ç¨‹,ä¼šå½±å“æ€§èƒ½ï¼Œå› ä¸ºæ“ä½œç³»ç»Ÿéœ€è¦åœ¨å®ƒä»¬ä¹‹é—´åˆ‡æ¢ï¼Œæ›´å¤šçš„çº¿ç¨‹éœ€è¦æ›´å¤šçš„å†…å­˜ç©ºé—´ï¼Œçº¿ç¨‹çš„ä¸­æ­¢éœ€è¦è€ƒè™‘å…¶å¯¹ç¨‹åºè¿è¡Œçš„å½±å“ã€‚é€šå¸¸å—æ¨¡å‹æ•°æ®æ˜¯åœ¨å¤šä¸ªçº¿ç¨‹é—´å…±äº«çš„ï¼Œéœ€è¦é˜²æ­¢çº¿ç¨‹æ­»é”æƒ…å†µçš„å‘ç”Ÿã€‚

æ€»ç»“:è¿›ç¨‹æ˜¯æ‰€æœ‰çº¿ç¨‹çš„é›†åˆï¼Œæ¯ä¸€ä¸ªçº¿ç¨‹æ˜¯è¿›ç¨‹ä¸­çš„ä¸€æ¡æ‰§è¡Œè·¯å¾„ã€‚

## 2.ä¸ºä»€ä¹ˆè¦ä½¿ç”¨å¤šçº¿ç¨‹ï¼Ÿå¤šçº¿ç¨‹åº”ç”¨åœºæ™¯ï¼Ÿ

ç­”:ä¸»è¦èƒ½ä½“ç°åˆ°å¤šçº¿ç¨‹æé«˜ç¨‹åºæ•ˆç‡ã€‚

ä¸¾ä¾‹: è¿…é›·å¤šçº¿ç¨‹ä¸‹è½½ã€æ•°æ®åº“è¿æ¥æ± ã€åˆ†æ‰¹å‘é€çŸ­ä¿¡ç­‰ã€‚

## 3.çº¿ç¨‹åˆ›å»ºæ–¹å¼

### ç»§æ‰¿Threadç±»é‡å†™runæ–¹æ³•

```java
class PlayGame extends Thread {
	public void run() {
		for (int i = 0; i < 50; i++) {
			System.out.println("PlayGame" + (i + 1));
		}
	}
	//void say() {}
}

class ListenMusic extends Thread {
	public void run() {
		for (int i = 0; i < 50; i++) {
			System.out.println("ListenMusic" + (i + 1));//åº•å±‚æ“ä½œå±…ç„¶æ˜¯ç”¨çš„StringBuilder
		}
	}
}

public class ThreadDemo {
	public static void main(String[] args)
	{
		Thread music = new ListenMusic();
		Thread pg = new PlayGame();
		music.start(); //ä¸‰ä¸ªçº¿ç¨‹åŒæ—¶è¿è¡ŒæŠ¢å èµ„æº
		try {
			pg.start();
			for (int i = 0; i < 50; i++) {
				System.out.println("    mainæ–¹æ³•:" + (i + 1));
			}
			pg.start();
		} catch (Exception e) {
			System.out.println("å‡ºç°äº†IllegalThreadStateExceptionå¼‚å¸¸");	  //çº¿ç¨‹åªèƒ½å¯åŠ¨ä¸€æ¬¡
		}
	}
}

```
è¿™ç§æ–¹æ³•å®˜æ–¹ä¹Ÿä¸æ¨èä½¿ç”¨å› ä¸ºJavaæ˜¯å•ç»§æ‰¿çš„ç»§æ‰¿äº†Threadç±»ä¹‹åå°±ä¸èƒ½ç»§æ‰¿å…¶ä»–çš„ç±»

### å®ç°Runnableæ¥å£

```java
class CreateRunnable implements Runnable {

	@Override
	public void run() {
		for (inti = 0; i< 10; i++) {
			System.out.println("i:" + i);
		}
	}

}

public class ThreadDemo2 {
	public static void main(String[] args) {
		System.out.println("-----å¤šçº¿ç¨‹åˆ›å»ºå¼€å§‹-----");
		// 1.åˆ›å»ºä¸€ä¸ªçº¿ç¨‹
		CreateRunnable createThread = new CreateRunnable();
		// 2.å¼€å§‹æ‰§è¡Œçº¿ç¨‹ æ³¨æ„ å¼€å¯çº¿ç¨‹ä¸æ˜¯è°ƒç”¨runæ–¹æ³•ï¼Œè€Œæ˜¯startæ–¹æ³•
		System.out.println("-----å¤šçº¿ç¨‹åˆ›å»ºå¯åŠ¨-----");
		Thread thread = new Thread(createThread);
		thread.start();
		System.out.println("-----å¤šçº¿ç¨‹åˆ›å»ºç»“æŸ-----");
	}
}

```
### åŒ¿åå†…éƒ¨ç±»

```java
public class InClass {
	public static void main(String[] args) {
		 Thread thread = new Thread(new Runnable() {
				public void run() {
					for (int i = 0; i< 100; i++) {
						System.out.println("i:" + i);
					}
				}
			});
		thread.start();

		 //lambdaè¡¨è¾¾å¼è¿˜æ˜¯æ¯”è¾ƒç®€æ´
		 new Thread(()-> {for (int i = 0; i <100; i++) {System.out.println("lambda:" +i);}}).start();
	}
}

```
çº¿ç¨‹åˆ›å»ºæ–¹å¼ä¸åªè¿™äº›è¿˜æœ‰å¾ˆå¤šï¼Œåé¢å†ä»‹ç»

### Thread ç±»ä¸­çš„start() å’Œ run() æ–¹æ³•æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

è¿™ä¸ªé—®é¢˜ç»å¸¸è¢«é—®åˆ°ï¼Œä½†è¿˜æ˜¯èƒ½ä»æ­¤åŒºåˆ†å‡ºé¢è¯•è€…å¯¹Javaçº¿ç¨‹æ¨¡å‹çš„ç†è§£ç¨‹åº¦ã€‚`start()`æ–¹æ³•è¢«ç”¨æ¥å¯åŠ¨æ–°åˆ›å»ºçš„çº¿ç¨‹ï¼Œè€Œä¸”`start()`å†…éƒ¨nativeæ–¹æ³•`start0()`è°ƒç”¨äº†run()æ–¹æ³•ï¼Œè¿™å’Œç›´æ¥è°ƒç”¨`run()`æ–¹æ³•çš„æ•ˆæœä¸ä¸€æ ·ã€‚å½“ä½ è°ƒç”¨`run()`æ–¹æ³•çš„æ—¶å€™ï¼Œåªä¼šæ˜¯åœ¨åŸæ¥çš„çº¿ç¨‹ä¸­è°ƒç”¨ï¼Œæ²¡æœ‰æ–°çš„çº¿ç¨‹å¯åŠ¨ï¼Œ`start()`æ–¹æ³•æ‰ä¼šå¯åŠ¨æ–°çº¿ç¨‹

## 4.Threadæ„é€ å‡½æ•°

| **å¸¸ç”¨çº¿ç¨‹apiæ–¹æ³•**| |
|:--|---|
| start()| å¯åŠ¨çº¿ç¨‹|
| currentThread()| è·å–å½“å‰çº¿ç¨‹å¯¹è±¡|
| getID()| è·å–å½“å‰çº¿ç¨‹ID   Thread-ç¼–å· è¯¥ç¼–å·ä»0å¼€å§‹|
| getName()| è·å–å½“å‰çº¿ç¨‹åç§°|
| sleep(long mill)| ä¼‘çœ çº¿ç¨‹|
| Stopï¼ˆï¼‰| åœæ­¢çº¿ç¨‹,|
| **å¸¸ç”¨çº¿ç¨‹æ„é€ å‡½æ•°** | |
| Threadï¼ˆï¼‰| åˆ†é…ä¸€ä¸ªæ–°çš„ Thread å¯¹è±¡|
| Threadï¼ˆString nameï¼‰| åˆ†é…ä¸€ä¸ªæ–°çš„ Threadå¯¹è±¡ï¼Œå…·æœ‰æŒ‡å®šçš„ nameæ­£å¦‚å…¶åã€‚|
| Threadï¼ˆRunnable rï¼‰| åˆ†é…ä¸€ä¸ªæ–°çš„ Threadå¯¹è±¡|
| Threadï¼ˆRunable r, String nameï¼‰| åˆ†é…ä¸€ä¸ªæ–°çš„ Threadå¯¹è±¡ï¼Œå…·æœ‰æŒ‡å®šçš„ nameæ­£å¦‚å…¶åã€‚|
| Thread(ThreadGroup group, Runnable target) | åˆ†é…ä¸€ä¸ªæ–°çš„ Threadå¯¹è±¡ï¼Œå¦‚æœä¸ä¼ `ThreadGroup`é»˜è®¤åŠ å…¥å½“å‰çº¿ç¨‹çš„`ThreadGroup`ä¸­ |
| Thread(ThreadGroup group, Runnable target, String name) | åˆ†é…ä¸€ä¸ªæ–°çš„ `Thread`å¯¹è±¡ï¼Œä½¿å…¶å…·æœ‰  `target`ä½œä¸ºå…¶è¿è¡Œå¯¹è±¡ï¼Œå…·æœ‰æŒ‡å®šçš„ `name`ä½œä¸ºå…¶åç§°ï¼Œå±äº  `group`å¼•ç”¨çš„çº¿ç¨‹ç»„ã€‚ |
| Thread(ThreadGroup group, Runnable target, String name,  long stackSize) | åˆ†é…ä¸€ä¸ªæ–°çš„ `Thread`å¯¹è±¡ï¼Œä»¥ä¾¿å®ƒå…·æœ‰  `target`ä½œä¸ºå…¶è¿è¡Œå¯¹è±¡ï¼Œå°†æŒ‡å®šçš„ `name`æ­£å¦‚å…¶åï¼Œä»¥åŠå±äºè¯¥çº¿ç¨‹ç»„ç”±ç§°ä½œ  `group` ï¼Œå¹¶å…·æœ‰æŒ‡å®šçš„ *å †æ ˆå¤§å°* |

### Threadæ„é€ æ–¹æ³•çš„ä¸€äº›ç»†èŠ‚

ç›´æ¥ä¸Šæºç 

```java
private void init(ThreadGroup g, Runnable target, String name,
                  long stackSize, AccessControlContext acc,
                  boolean inheritThreadLocals) {
    if (name == null) {
        throw new NullPointerException("name cannot be null");
    }

    this.name = name;

    Thread parent = currentThread();
    SecurityManager security = System.getSecurityManager();
    if (g == null) {
        /* Determine if it's an applet or not */

        /* If there is a security manager, ask the security manager
               what to do. */
        if (security != null) {
            g = security.getThreadGroup();
        }

        /* If the security doesn't have a strong opinion of the matter
               use the parent thread group. */
        if (g == null) {
            g = parent.getThreadGroup();
        }
    }

    /* checkAccess regardless of whether or not threadgroup is
           explicitly passed in. */
    g.checkAccess();

    /*
         * Do we have the required permissions?
         */
    if (security != null) {
        if (isCCLOverridden(getClass())) {
            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
        }
    }

    g.addUnstarted();
    this.group = g;
    //è¿™é‡Œç»§æ‰¿äº†çˆ¶ç±»çš„ä¸€äº›å±æ€§
    this.daemon = parent.isDaemon();
    this.priority = parent.getPriority();

    if (security == null || isCCLOverridden(parent.getClass()))
        this.contextClassLoader = parent.getContextClassLoader();
    else
        this.contextClassLoader = parent.contextClassLoader;
    this.inheritedAccessControlContext =
        acc != null ? acc : AccessController.getContext();
    //ä¼ å…¥çš„Runnableæ¥å£
    this.target = target;
    setPriority(priority);
    if (inheritThreadLocals && parent.inheritableThreadLocals != null)
        this.inheritableThreadLocals =
        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
    /* Stash the specified stack size in case the VM cares */
    this.stackSize = stackSize;

    /* Set thread ID */
    tid = nextThreadID();
}
```

â‘  åˆ›å»ºçš„çº¿ç¨‹ä¼šç»§æ‰¿çˆ¶çº¿ç¨‹çš„ä¸€äº›å±æ€§ï¼Œæ˜¯å¦æ˜¯å®ˆæŠ¤çº¿ç¨‹ ï¼Œå’Œä¼˜å…ˆçº§ã€‚

â‘¡ä½¿ç”¨Thread(Runnable r)åˆ›å»ºçº¿ç¨‹æ—¶`this.target = target`ä¼ å…¥çš„`Runnable`æ¥å£åœ¨è¿™é‡Œèµ‹å€¼ç„¶åä¼šåœ¨`runæ–¹æ³•`ä¸­è¢«è°ƒç”¨ã€‚

â‘¢`stacksize`è¿™ä¸ªå‚æ•°ä¼šå½±å“`è™šæ‹Ÿæœºæ ˆ`çš„å¤§å°ï¼Œè¿™ä¸ªå€¼è¶Šå¤§èƒ½å­˜æ”¾çš„`æ ˆå¸§`å°±è¶Šå¤šï¼Œå¯è¾¾åˆ°çš„é€’å½’æ·±åº¦è¶Šæ·±ï¼Œä½†æ˜¯è¿™ä¸ªå‚æ•°ä¸ä¸€å®šæœ‰æ•ˆï¼Œæœ‰çš„å¹³å°å¯èƒ½å¹¶æ²¡æœ‰æ•ˆæœï¼Œå…·ä½“çš„`JVM`åº•å±‚çš„çŸ¥è¯†ç­‰åé¢å­¦åˆ°å†æ¥ç»†åŒ–

â‘£ä¸€ç§å¥‡æ€ªçš„å†™æ³•ï¼Œè¿™é‡Œåªä¼šæ‰§è¡Œé‡å†™`Thread`çš„`run`æ–¹æ³•ï¼Œè¿™é‡Œä»æºç ä¸Šå¯ä»¥çœ‹å‡ºæ¥ï¼Œä¼ é€’`Runnable`æ¥å£å…¶å®æ˜¯åœ¨Threadçš„runæ–¹æ³•ä¸­è°ƒç”¨äº†`target`çš„`run`æ–¹æ³•ï¼Œå¦‚æœåŒæ—¶å†`ç»§æ‰¿`Threadç±»ï¼Œé‡å†™`run`æ–¹æ³•ï¼Œè°ƒç”¨çš„å°±ä¸å†æ˜¯Threadç±»çš„runæ–¹æ³•ï¼Œè€Œæ˜¯åŒ¿åThreadå­ç±»é‡å†™çš„runæ–¹æ³•

```java
Thread t = new Thread(() -> {
    System.out.println("Runnable");
}) {
    @Override
    public void run() {
        System.out.println("Thread");
    }
};
```

â‘£çº¿ç¨‹`tid`é€šè¿‡`threadSeqNumber`ä»0è‡ªå¢çš„æ¥ï¼Œmainçº¿ç¨‹æ˜¯ç¬¬`10`ä¸ªçº¿ç¨‹å› ä¸ºä¼šæœ‰ä¸€äº›å®ˆæŠ¤çº¿ç¨‹ä¼šåœ¨mainå¯åŠ¨å‰å¯åŠ¨.

## 5.å®ˆæŠ¤çº¿ç¨‹

Javaä¸­æœ‰ä¸¤ç§çº¿ç¨‹ï¼Œä¸€ç§æ˜¯ç”¨æˆ·çº¿ç¨‹ï¼Œå¦ä¸€ç§æ˜¯å®ˆæŠ¤çº¿ç¨‹ã€‚

ç”¨æˆ·çº¿ç¨‹æ˜¯æŒ‡ç”¨æˆ·è‡ªå®šä¹‰åˆ›å»ºçš„çº¿ç¨‹ï¼Œä¸»çº¿ç¨‹åœæ­¢ï¼Œç”¨æˆ·çº¿ç¨‹ä¸ä¼šåœæ­¢

- å®ˆæŠ¤çº¿ç¨‹é¡¾åæ€ä¹‰å½“çˆ¶çº¿ç¨‹ç»“æŸæ—¶ï¼Œå®ˆæŠ¤çº¿ç¨‹ä¹Ÿä¼šè¢«åœæ­¢ã€‚
- JVMåªæœ‰åœ¨æœ€åä¸€ä¸ªéå®ˆæŠ¤çº¿ç¨‹ç»“æŸåæ‰ä¼šé€€å‡º
- åœ¨çº¿ç¨‹startå‰`setDaemon(true)`æ–¹æ³•è®¾ç½®ä¸ºå®ˆæŠ¤çº¿ç¨‹ï¼Œå¦åˆ™å°±ä¼šæŠ¥é”™
- çˆ¶çº¿ç¨‹æ˜¯å®ˆæŠ¤çº¿ç¨‹ï¼Œå­çº¿ç¨‹é»˜è®¤æ˜¯å®ˆæŠ¤çº¿ç¨‹ã€‚

```java
class Daemon implements Runnable {
    public void run() {
        for(int i=0;i<500;i++) {
            System.out.println(Thread.currentThread().getName()+i);
        }
    }
}

public class DaemonDemo {
    public static void main(String[]args) {
        System.out.println(Thread.currentThread().getPriority());
        Thread r1=new Thread(new Daemon(),"åå°çº¿ç¨‹");     //è®¾ç½®è¯¥çº¿ç¨‹ä¸ºåå°çº¿ç¨‹
        r1.setDaemon(true);                        //å‰å°çº¿ç¨‹æŒ‚æ‰åï¼Œåå°çº¿ç¨‹å°±ä¼šæŒ‚æ‰
        for(int i=0;i<50;i++) {                   
            System.out.println("main"+i);
            if(i==10) {
                r1.start();
            }
        }
        System.out.println("ä¸»çº¿ç¨‹æ‰§è¡Œå®Œæ¯•");
    }
}
```

### åº”ç”¨åœºæ™¯

`å¿ƒè·³æ£€æµ‹`ï¼Œåœ¨é€šä¿¡è¿‡ç¨‹ä¸­ä¼šéœ€è¦åˆ¤æ–­å¯¹æ–¹æ˜¯å¦åœ¨çº¿ï¼Œä¼šéœ€è¦åˆ›å»ºä¸€æ¡çº¿ç¨‹å»åšè¿™äº›äº‹æƒ…ï¼Œä½†æ˜¯å¦‚æœè¿™æ ·ä¼šå¯¼è‡´`ä¸»çº¿ç¨‹åœæ­¢å·¥ä½œ`äº†ï¼Œä½†æ˜¯æ£€æµ‹å¿ƒè·³çš„çº¿ç¨‹ä»ç„¶åœ¨ç»§ç»­å·¥ä½œï¼ŒJVMå°±æ— æ³•åœä¸‹æ¥ï¼Œæ˜¾ç„¶è¿™æ ·æ—¶ä¸åˆç†çš„ï¼Œè¿™æ—¶å°±å¯ä»¥æŠŠæ£€æµ‹å¿ƒè·³çš„çº¿ç¨‹è®¾ç½®ä¸º`å®ˆæŠ¤çº¿ç¨‹`ï¼Œè¿™æ ·å½“å®ƒä¸»çº¿ç¨‹åœæ­¢å·¥ä½œæ—¶å®ƒçš„å®ˆæŠ¤çº¿ç¨‹ä¹Ÿä¼šéšä¹‹åœæ­¢ã€‚

```java
//å¿ƒè·³æ£€æµ‹MOCK
public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(() -> {
            Thread inThread = new Thread(() -> {
                while (true) {
                    System.out.println("start heart check");
                    try {
                        Thread.sleep(1_00);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
            //å°†å­çº¿ç¨‹è®¾ç½®ä¸ºå®ˆæŠ¤çº¿ç¨‹
            inThread.setDaemon(true);
            inThread.start();
            try {
                Thread.sleep(1_000);
                System.err.println("Thread finish done...");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        t.start();
        //ä¸»çº¿ç¨‹(main)-->t-->inThread
    }
```

## 6.çº¿ç¨‹çš„çŠ¶æ€

çº¿ç¨‹ä»åˆ›å»ºã€è¿è¡Œåˆ°ç»“æŸæ€»æ˜¯å¤„äºä¸‹é¢äº”ä¸ªçŠ¶æ€ä¹‹ä¸€ï¼šæ–°å»ºçŠ¶æ€ã€å°±ç»ªçŠ¶æ€ã€è¿è¡ŒçŠ¶æ€ã€é˜»å¡çŠ¶æ€åŠæ­»äº¡çŠ¶æ€ã€‚

![mark](http://static.imlgw.top///20181226/WXPYz3SiidMT.png?imageslim)

- æ–°å»ºçŠ¶æ€
  å½“ç”¨newæ“ä½œç¬¦åˆ›å»ºä¸€ä¸ªçº¿ç¨‹æ—¶ï¼Œ ä¾‹å¦‚new Thread(r)ï¼Œçº¿ç¨‹è¿˜æ²¡æœ‰å¼€å§‹è¿è¡Œï¼Œæ­¤æ—¶çº¿ç¨‹å¤„åœ¨æ–°å»ºçŠ¶æ€ã€‚ å½“ä¸€ä¸ªçº¿ç¨‹å¤„äºæ–°ç”ŸçŠ¶æ€æ—¶ï¼Œç¨‹åºè¿˜æ²¡æœ‰å¼€å§‹è¿è¡Œçº¿ç¨‹ä¸­çš„ä»£ç 

- å°±ç»ªçŠ¶æ€
  ä¸€ä¸ªæ–°åˆ›å»ºçš„çº¿ç¨‹å¹¶ä¸è‡ªåŠ¨å¼€å§‹è¿è¡Œï¼Œè¦æ‰§è¡Œçº¿ç¨‹ï¼Œå¿…é¡»è°ƒç”¨çº¿ç¨‹çš„start()æ–¹æ³•ã€‚å½“çº¿ç¨‹å¯¹è±¡è°ƒç”¨start()æ–¹æ³•å³å¯åŠ¨äº†çº¿ç¨‹ï¼Œstart()æ–¹æ³•åˆ›å»ºçº¿ç¨‹è¿è¡Œçš„ç³»ç»Ÿèµ„æºï¼Œå¹¶è°ƒåº¦çº¿ç¨‹è¿è¡Œrun()æ–¹æ³•ã€‚å½“start()æ–¹æ³•è¿”å›åï¼Œçº¿ç¨‹å°±å¤„äºå°±ç»ªçŠ¶æ€ã€‚
  å¤„äºå°±ç»ªçŠ¶æ€çš„çº¿ç¨‹å¹¶ä¸ä¸€å®šç«‹å³è¿è¡Œrun()æ–¹æ³•ï¼Œçº¿ç¨‹è¿˜å¿…é¡»åŒå…¶ä»–çº¿ç¨‹ç«äº‰CPUæ—¶é—´ï¼Œåªæœ‰è·å¾—CPUæ—¶é—´æ‰å¯ä»¥è¿è¡Œçº¿ç¨‹ã€‚å› ä¸ºåœ¨å•CPUçš„è®¡ç®—æœºç³»ç»Ÿä¸­ï¼Œä¸å¯èƒ½åŒæ—¶è¿è¡Œå¤šä¸ªçº¿ç¨‹ï¼Œä¸€ä¸ªæ—¶åˆ»ä»…æœ‰ä¸€ä¸ªçº¿ç¨‹å¤„äºè¿è¡ŒçŠ¶æ€ã€‚å› æ­¤æ­¤æ—¶å¯èƒ½æœ‰å¤šä¸ªçº¿ç¨‹å¤„äºå°±ç»ªçŠ¶æ€ã€‚å¯¹å¤šä¸ªå¤„äºå°±ç»ªçŠ¶æ€çš„çº¿ç¨‹æ˜¯ç”±`Java`è¿è¡Œæ—¶ç³»ç»Ÿçš„çº¿ç¨‹è°ƒåº¦ç¨‹åº(*thread scheduler*)æ¥è°ƒåº¦çš„ã€‚

- è¿è¡ŒçŠ¶æ€
  å½“çº¿ç¨‹è·å¾—CPUæ—¶é—´åï¼Œå®ƒæ‰è¿›å…¥è¿è¡ŒçŠ¶æ€ï¼ŒçœŸæ­£å¼€å§‹æ‰§è¡Œrun()æ–¹æ³•.

- é˜»å¡çŠ¶æ€
  çº¿ç¨‹è¿è¡Œè¿‡ç¨‹ä¸­ï¼Œå¯èƒ½ç”±äºå„ç§åŸå› è¿›å…¥é˜»å¡çŠ¶æ€:
  1>çº¿ç¨‹é€šè¿‡è°ƒç”¨sleepæ–¹æ³•è¿›å…¥ç¡çœ çŠ¶æ€ï¼›
  2>çº¿ç¨‹è°ƒç”¨ä¸€ä¸ªåœ¨I/Oä¸Šè¢«é˜»å¡çš„æ“ä½œï¼Œå³è¯¥æ“ä½œåœ¨è¾“å…¥è¾“å‡ºæ“ä½œå®Œæˆä¹‹å‰ä¸ä¼šè¿”å›åˆ°å®ƒçš„è°ƒç”¨è€…ï¼›
  3>çº¿ç¨‹è¯•å›¾å¾—åˆ°ä¸€ä¸ªé”ï¼Œè€Œè¯¥é”æ­£è¢«å…¶ä»–çº¿ç¨‹æŒæœ‰ï¼›
  4>çº¿ç¨‹åœ¨ç­‰å¾…æŸä¸ªè§¦å‘æ¡ä»¶ï¼›

- æ­»äº¡çŠ¶æ€

  æœ‰ä¸¤ä¸ªåŸå› ä¼šå¯¼è‡´çº¿ç¨‹æ­»äº¡ï¼š

  1) runæ–¹æ³•æ­£å¸¸é€€å‡ºè€Œè‡ªç„¶æ­»äº¡ï¼Œ

  2) ä¸€ä¸ªæœªæ•è·çš„å¼‚å¸¸ç»ˆæ­¢äº†runæ–¹æ³•è€Œä½¿çº¿ç¨‹çŒæ­»ã€‚ ä¸ºäº†ç¡®å®šçº¿ç¨‹åœ¨å½“å‰æ˜¯å¦å­˜æ´»ç€ï¼ˆå°±æ˜¯è¦ä¹ˆæ˜¯å¯è¿è¡Œçš„ï¼Œè¦ä¹ˆæ˜¯è¢«é˜»å¡äº†ï¼‰ï¼Œéœ€è¦ä½¿ç”¨`isAlive`æ–¹æ³•ã€‚å¦‚æœæ˜¯å¯è¿è¡Œæˆ–è¢«é˜»å¡ï¼Œè¿™ä¸ªæ–¹æ³•è¿”å›trueï¼› å¦‚æœçº¿ç¨‹ä»æ—§æ˜¯newçŠ¶æ€ä¸”ä¸æ˜¯å¯è¿è¡Œçš„ï¼Œ æˆ–è€…çº¿ç¨‹æ­»äº¡äº†ï¼Œåˆ™è¿”å›false.

## 7.join()æ–¹æ³•

### æºç è§£æ

```java
 public final synchronized void join(long millis) throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;
        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }
        if (millis == 0) {
            while (isAlive()) {
                wait(0);
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                if (delay <= 0) {
                    break;
                }
                wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
    }
```

â‘ `thread.join()`æ²¡æœ‰å‚æ•°ä¼šé»˜è®¤è°ƒç”¨`join(0)`ç„¶åå›è½®è¯¢æ£€æŸ¥è°ƒç”¨`join()`çš„çº¿ç¨‹ä¹Ÿå°±æ˜¯æ˜¯`thread`çº¿ç¨‹æ˜¯å¦`isAlive()`å¦‚æœthreadä¾ç„¶å­˜æ´»å°±å›é‡Šæ”¾`å½“å‰çº¿ç¨‹`çš„CPUæ‰§è¡Œæƒï¼Œç„¶åç»§ç»­è½®è¯¢ï¼ŒçŸ¥é“`thread`è¿›å…¥ç»ˆæ­¢çŠ¶æ€ã€‚

â‘¡`join(long millis)` å‚æ•°çš„ä½œç”¨å°±æ˜¯å½“å‰çº¿ç¨‹æœ€å¤šç­‰å¾…æ—¶é—´ï¼Œé™æ—¶ç­‰å¾…ï¼Œé¿å…æ— æ­¢å¢ƒçš„ç­‰å¾…ã€‚

â‘¢ä¸€ä¸ªçº¿ç¨‹è‡ªå·±è°ƒç”¨è‡ªå·±çš„`join`æ–¹æ³•è¯¥çº¿ç¨‹å°±å›ä¸€ç›´`wait`ä¸‹å»å› ä¸ºä»–è‡ªå·±è¦ä¸€ç›´ç­‰è‡ªå·±ğŸ˜„

### åº”ç”¨åœºæ™¯

>  å¤šçº¿ç¨‹åŒæ—¶é‡‡é›†æ•°æ®ï¼Œæœ€åå°†ç»Ÿè®¡çš„æ€»æ—¶é—´ç­‰ä¿¡æ¯å­˜åˆ°æ•°æ®åº“ä¸­ï¼Œå¦‚æœä¸jionå°±æ— æ³•ç»Ÿä¸€ç»“æŸçš„æ—¶é—´

```java
public class ThreadJoin3 {
    public static void main(String[] args) throws InterruptedException {
        long l1 = System.currentTimeMillis();
        Thread t0 = new Thread(new CaptureMachine("M0", 1000));
        Thread t1 = new Thread(new CaptureMachine("M1", 2000));
        Thread t2 = new Thread(new CaptureMachine("M2", 4000));
        t0.start();
        t1.start();
        t2.start();
        //è®©ä¸»çº¿ç¨‹ç­‰å¾…å­çº¿ç¨‹ç»“æŸç„¶åç»Ÿè®¡æœ€åæ€»ä½“ç»“æŸçš„æ—¶é—´
        t0.join();
        t1.join();
        t2.join();
        long l = System.currentTimeMillis();
        System.out.println("end save begin timestamp:" + l1 + "end timestamp" + l);
    }
}

class CaptureMachine implements Runnable {
    private String machineId;

    private long spentTime;

    public CaptureMachine(String machineId, long spentTime) {
        this.machineId = machineId;
        this.spentTime = spentTime;
    }

    @Override
    public void run() {
        try {
            Thread.sleep(spentTime);
            System.out.println(machineId + " capture done");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

## 8.ä¼˜å…ˆçº§

ç°ä»£æ“ä½œç³»ç»ŸåŸºæœ¬é‡‡ç”¨æ—¶åˆ†çš„å½¢å¼è°ƒåº¦è¿è¡Œçš„çº¿ç¨‹ï¼Œçº¿ç¨‹åˆ†é…å¾—åˆ°çš„æ—¶é—´ç‰‡çš„å¤šå°‘å†³å®šäº†çº¿ç¨‹ä½¿ç”¨å¤„ç†å™¨èµ„æºçš„å¤šå°‘ï¼Œä¹Ÿå¯¹åº”äº†çº¿ç¨‹ä¼˜å…ˆçº§è¿™ä¸ªæ¦‚å¿µã€‚åœ¨JAVAçº¿ç¨‹ä¸­ï¼Œé€šè¿‡ä¸€ä¸ªint priorityæ¥æ§åˆ¶ä¼˜å…ˆçº§ï¼ŒèŒƒå›´ä¸º1-10ï¼Œå…¶ä¸­10æœ€é«˜ï¼Œé»˜è®¤å€¼ä¸º5ã€‚ä¸‹é¢æ˜¯Demoï¼ˆåŸºäº1.8ï¼‰ä¸­å…³äºpriorityçš„ä¸€äº›é‡å’Œæ–¹æ³•ã€‚

```java
public class ThreadSimpleAPI2 {
    public static void main(String[] args) {
        Thread t0 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                Optional.of(Thread.currentThread().getName() + "-index" + i).ifPresent(System.out::println);
            }
        });
        t0.setPriority(Thread.MAX_PRIORITY);
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                Optional.of(Thread.currentThread().getName() + "-index" + i).ifPresent(System.out::println);
            }
        });
        t1.setPriority(Thread.NORM_PRIORITY);
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                Optional.of(Thread.currentThread().getName() + "-index" + i).ifPresent(System.out::println);
            }
        });
        t2.setPriority(Thread.MIN_PRIORITY);
        t0.start();
        t1.start();
        t2.start();
    }
}
```

## 9.Interruptæ–¹æ³• 

### çœ‹çœ‹æºç 

```java
public void interrupt() {
        if (this != Thread.currentThread())
            checkAccess();

        synchronized (blockerLock) {
            Interruptible b = blocker;
            if (b != null) {
                interrupt0();           // Just to set the interrupt flag
                b.interrupt(this);
                return;
            }
        }
        interrupt0();
}
```

åœ¨çŸ¥ä¹ä¸Šçœ‹è§ä¸€ä¸ªå¥½çš„å›ç­”ï¼šé¦–å…ˆï¼Œä¸€ä¸ªçº¿ç¨‹ä¸åº”è¯¥ç”±å…¶ä»–çº¿ç¨‹æ¥å¼ºåˆ¶ä¸­æ–­æˆ–åœæ­¢ï¼Œè€Œæ˜¯åº”è¯¥ç”±çº¿ç¨‹è‡ªå·±`è‡ªè¡Œåœæ­¢`ã€‚æ‰€ä»¥ï¼Œ`Thread.stop()` ,`Thread.suspend()`,`Thread.resume()`éƒ½å·²ç»è¢«åºŸå¼ƒäº†ã€‚è€Œ`Thread.interrupt()`çš„ä½œç”¨ä¹Ÿä¸æ˜¯ä¸­æ–­çº¿ç¨‹ï¼Œ_è€Œæ˜¯é€šçŸ¥çº¿ç¨‹è¯¥ç»“æŸäº†_ å…·ä½“ä¸­æ–­è¿˜æ˜¯ç»§ç»­è¿è¡Œè¿˜æ˜¯ç”±è¢«é€šçŸ¥çš„çº¿ç¨‹è‡ªå·±å¤„ç†ã€‚å…·ä½“æ¥è¯´ï¼Œå½“å¯¹ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨`interrupt()`æ—¶

â‘ å¦‚æœçº¿ç¨‹å¤„äºé˜»å¡çŠ¶æ€(sleep,wait,joinç­‰)ï¼Œé‚£ä¹ˆçº¿ç¨‹å°†~~ç«‹å³é€€å‡ºè¢«é˜»å¡çŠ¶æ€~~å¹¶æŠ›å‡ºä¸€ä¸ªå¼‚å¸¸(2019.8.10 fix)

> è¿™é‡Œå…¶å®æ˜¯æœ‰ç‚¹é—®é¢˜çš„ï¼Œåœ¨æœ‰åŒæ­¥é”å­˜åœ¨çš„æƒ…å†µä¸‹ï¼Œå¹¶ä¸ä¸€å®šä¼šç«‹å³é€€å‡ºè¢«é˜»å¡çš„çŠ¶æ€ï¼Œå³ä½¿æŠ›å‡ºå¼‚å¸¸ä¹Ÿè¦ç­‰åˆ°å†æ¬¡æ‹¿åˆ°é”ä¹‹åæ‰èƒ½æŠ›å‡ºï¼ŒåŒæ—¶ä¹Ÿä¸æ˜¯æ‰€æœ‰çš„é˜»å¡æ“ä½œéƒ½ä¼šå“åº”ä¸­æ–­ä¿¡å·ï¼Œæ¯”å¦‚IOæ“ä½œä¹‹ç±»çš„éƒ½ä¸ä¼šå“åº”ä¸­æ–­ä¿¡å·

**éªŒè¯Demo**

```java
public class WaitNotify {

    public static void main(String[] args) {

        Object object = new Object();

        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (object) {
                    System.out.println("çº¿ç¨‹1 è·å–åˆ°ç›‘è§†å™¨é”");
                    try {
                        object.wait();
                        System.out.println("çº¿ç¨‹1 æ¢å¤å•¦ã€‚æˆ‘ä¸ºä»€ä¹ˆè¿™ä¹ˆä¹…æ‰æ¢å¤ï¼Œå› ä¸ºnotifyæ–¹æ³•è™½ç„¶æ—©å°±å‘ç”Ÿäº†ï¼Œå¯æ˜¯æˆ‘è¿˜è¦è·å–é”æ‰èƒ½ç»§ç»­æ‰§è¡Œã€‚");
                    } catch (InterruptedException e) {
                        System.out.println("çº¿ç¨‹1 waitæ–¹æ³•æŠ›å‡ºäº†InterruptedExceptionå¼‚å¸¸ï¼Œå³ä½¿æ˜¯å¼‚å¸¸ï¼Œæˆ‘ä¹Ÿæ˜¯è¦è·å–åˆ°ç›‘è§†å™¨é”äº†æ‰ä¼šæŠ›å‡º");
                    }
                }
            }
        }, "çº¿ç¨‹1");
        thread1.start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (object) {
                    System.out.println("çº¿ç¨‹2 æ‹¿åˆ°äº†ç›‘è§†å™¨é”ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Œå› ä¸ºçº¿ç¨‹1 åœ¨ wait æ–¹æ³•çš„æ—¶å€™ä¼šè‡ªåŠ¨é‡Šæ”¾é”");
                    System.out.println("çº¿ç¨‹2 è®¾ç½®çº¿ç¨‹1 ä¸­æ–­");
                    thread1.interrupt();
                    System.out.println("çº¿ç¨‹2 æ‰§è¡Œå®Œäº† ä¸­æ–­ï¼Œå…ˆä¼‘æ¯3ç§’å†è¯´ã€‚");
                    try {
                        Thread.sleep(3000);
                        System.out.println("çº¿ç¨‹2 ä¼‘æ¯å®Œå•¦ã€‚æ³¨æ„äº†ï¼Œè°ƒsleepæ–¹æ³•å’Œwaitæ–¹æ³•ä¸ä¸€æ ·ï¼Œä¸ä¼šé‡Šæ”¾ç›‘è§†å™¨é”");
                    } catch (InterruptedException e) {

                    }
                    System.out.println("çº¿ç¨‹2 ä¼‘æ¯å¤Ÿäº†ï¼Œç»“æŸæ“ä½œ");
                }
            }
        }, "çº¿ç¨‹2").start();
    }
}
```

â‘¡å¦‚æœçº¿ç¨‹å¤„äºæ­£å¸¸æ´»åŠ¨çŠ¶æ€ï¼Œé‚£ä¹ˆä¼šå°†è¯¥çº¿ç¨‹çš„`ä¸­æ–­æ ‡å¿—ä½`è®¾ç½®ä¸ºtrueï¼Œä»…æ­¤è€Œå·²ï¼Œè¢«è®¾ç½®ä¸­æ–­æ ‡å¿—çš„çº¿ç¨‹å°†ç»§ç»­æ­£å¸¸è¿è¡Œï¼Œä¸å—å½±å“ã€‚

â‘¢å¯¹å·²ç»ç»“æŸçš„çº¿ç¨‹è°ƒç”¨`interupt`æ²¡æœ‰ä»»ä½•æ•ˆæœ

ä¸Šé¢åªæ˜¯ç®€å•çš„åˆ†æï¼Œå…¶å®æƒ…å†µè¿˜æ˜¯å¾ˆå¤æ‚çš„ï¼Œåé¢å†æ¥æ€»ç»“

**å…·ä½“çš„å°æ¡ˆä¾‹**

```java
public class ThreadInterrup2 {
    public static void main(String[] args) {
        Thread main=Thread.currentThread();

        Thread t=new Thread(()->{
            while (true){

            }
        });
        t.start();
	
        Thread t2 = new Thread(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //t.interrupt(); è¿™é‡Œæ‰“æ–­çš„æ˜¯tçº¿ç¨‹ä½†æ˜¯é˜»å¡çš„æ˜¯mainçº¿ç¨‹æ‰€ä»¥æ‰“æ–­ä¸äº†ï¼Œæ•è·ä¸åˆ°å¼‚å¸¸
            main.interrupt();
            System.out.println("æ‰“æ–­ main çº¿ç¨‹");
        });
        t2.start();

        try {
            //è¿™é‡Œé˜»å¡çš„æ˜¯mainçº¿ç¨‹
            t.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

```

çœ‹æ‡‚è¿™ä¸ªå°æ¡ˆä¾‹åº”è¯¥å°±ç†è§£interruptäº†ã€‚

### å¦‚ä½•ä¼˜é›…çš„ç»“æŸçº¿ç¨‹

**1. ä½¿ç”¨â€œå¼€å…³â€**

```java
public class ThreadCloseGraceful {
    public static void main(String[] args) throws InterruptedException {
        Worker worker=new Worker();
        worker.start();
        Thread.sleep(10000); //ç­‰å¾…10s
        worker.shutdown();
    }
}

class Worker extends Thread{
    //ä¼˜é›…çš„åœæ­¢çº¿ç¨‹-----å¼€å…³
    private volatile boolean start = true;

    @Override
    public void run() {
        while (start){

        }
    }

    public void shutdown(){
        this.start=false;
    }
}
```

> ä¸ºäº†åŠæ—¶çš„æ„ŸçŸ¥åˆ°å¼€å…³çš„å˜åŒ– startéœ€è¦å£°æ˜ä¸º volatileï¼ˆåé¢è®²Volatileçš„æ—¶å€™ä¼šè¯´åˆ°ï¼‰

**2. è½®è¯¢ä¸­æ–­æ ‡å¿—ä½**

```java
public class ThreadCloseGraceful2 {
    public static void main(String[] args) throws InterruptedException {
        Worker2 worker2 = new Worker2();
        worker2.start();
        Thread.sleep(5000);
        worker2.interrupt();
    }
}

class Worker2 extends Thread{
    //ä¼˜é›…çš„åœæ­¢çº¿ç¨‹2-----æ‰“æ–­
    @Override
    public void run() {
        while (true){
            /*try {
                Thread.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
                break; //return ä¼šç›´æ¥é€€å‡º
            }*/
            //ä»£ç æœ‰å¯èƒ½åœ¨æ‰§è¡ŒisInterruptedä¹‹å‰å°±Blockäº†
            if(isInterrupted()){
                break;
            }
        }
        //-----------
    }
}
```

**3. åˆ©ç”¨å®ˆæŠ¤çº¿ç¨‹**

ä¸Šé¢çš„ä»£ç å·²ç»æåˆ°äº†ï¼Œæœ‰å¯èƒ½åœ¨è½®è¯¢`å¼€å…³` æˆ–è€… è½®è¯¢`ä¸­æ–­æ ‡å¿—ä½`ä¹‹å‰å°±å µå¡äº†ï¼Œè¿™æ—¶ä¹Ÿä¸èƒ½ä¸€ç›´ç­‰è¯¥ä¸‹å»æ‰€ä»¥å°±éœ€è¦å¼ºåˆ¶ç»“æŸçº¿ç¨‹çš„æ–¹æ³•ï¼Œ`ï¼ˆå½“ç„¶ä¸ä¼šæ˜¯stopï¼‰` è¿™é‡Œå°±å¯ä»¥åˆ©ç”¨å®ˆæŠ¤çº¿ç¨‹çš„ç‰¹æ€§å»å®Œæˆè¿™ä»¶äº‹

```java
public class ThreadService {
    private  Thread executeThread;

    private  volatile  boolean finished=false;

    public void execute(Runnable task){
        executeThread =new Thread(()->{
            //å­çº¿ç¨‹
            Thread t=new Thread(()->{
                task.run();
            });
            t.setDaemon(true);
            t.start();

            try {
                t.join(); //è¿™é‡Œé˜»å¡çš„æ˜¯executeThread
                finished=true;
                //åˆ°è¿™é‡Œè¯´æ˜executeThreadå·²ç»ä¸é˜»å¡äº†,å­çº¿ç¨‹å·²ç»æ‰§è¡Œå®Œäº†ï¼Œæ²¡æœ‰è¶…æ—¶
            } catch (InterruptedException e) {
                e.printStackTrace();
                System.out.println("TLEï¼ŒexecuteThread execution was interrupted");
            }
        });
        executeThread.start();
    }

    public void shutdown(long mills){
        long base=System.currentTimeMillis();
        while (!finished){ //è½®è¯¢æ£€æŸ¥æ ‡å¿—ä½ï¼Œçœ‹æ˜¯å¦å·²ç»ç»“æŸ
            if(System.currentTimeMillis()-base>=mills){
                //è¶…æ—¶äº†æ²¡æœ‰å®Œæˆ
                System.out.println("TLE, will end it now");
                executeThread.interrupt(); //æ‰“æ–­executeThread
                break;
            }
            //æ²¡è¶…æ—¶
            try {
                executeThread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
                System.out.println("executeThread was interrupted when shutdown");
            }
        }
        //æ ‡å¿—ä½å¤åŸ
        finished=false;
    }
}
```

å°†å¾…æ‰§è¡Œçš„`task`ä¼ é€’åˆ°`ThreadService`ä¸­ç„¶åä¼šåˆ›å»ºä¸€ä¸ª`executeThread`çš„çº¿ç¨‹ï¼Œåœ¨çº¿ç¨‹ä¸­åˆ›å»ºä¸€ä¸ªå­çº¿ç¨‹å»æ‰§è¡Œ`task`çš„`run`æ–¹æ³•ç„¶åå°†å­çº¿ç¨‹è®¾ç½®ä¸º`executeThread`çš„å®ˆæŠ¤çº¿ç¨‹ç„¶å`join`é˜»å¡`executeThread`çº¿ç¨‹ï¼ŒåŒæ—¶ä¼šè°ƒç”¨`ThreadService`çš„`shutdown`æ–¹æ³•ä¼ å…¥ä¸€ä¸ªæœ€é•¿ç­‰å¾…æ—¶é—´ç„¶å`è½®è¯¢æ ‡å¿—ä½`æ£€æŸ¥æ˜¯å¦ç»“æŸï¼Œå¦‚æœè¶…æ—¶å°±ä¼šæ‰“æ–­`executeThread`è¿›è€Œç»“æŸ`executeThread`çš„å­çº¿ç¨‹ä¹Ÿå°±æ˜¯`task`

### Thread.interrupted()

è¿™ä¸ªæ–¹æ³•å’Œ`isInterrupt()`ç±»ä¼¼ä½†æ˜¯ä»–ä¼šæ¸…é™¤ä¸­æ–­æ ‡å¿—ä½ä¸º`false`æ–¹ä¾¿ä¹‹åçš„ä¸­æ–­æ“ä½œè€Œä¸”è¿™ä¸ªæ˜¯`é™æ€æ–¹æ³•`ï¼Œæ‰€ä»¥ä½ ç”¨çº¿ç¨‹å®ä¾‹å»è°ƒç”¨è¿™ä¸ªæ–¹æ³•æ²¡æœ‰ä»»ä½•æ„ä¹‰ï¼Œå®ƒè¿™é‡Œæ˜¯ç”¨æ¥åˆ¤æ–­**å½“å‰æ‰§è¡Œçº¿ç¨‹**æ˜¯å¦ `interrupt` ï¼Œå¹¶ä¸”è®¾ç½®ä¸­æ–­æ ‡å¿—ä½ä¸º`false`

```html
/**
 * Tests whether the current thread has been interrupted.  The
 * <i>interrupted status</i> of the thread is cleared by this method.  In
 * other words, if this method were to be called twice in succession, the
 * second call would return false (unless the current thread were
 * interrupted again, after the first call had cleared its interrupted
 * status and before the second call had examined it).
 *
 * <p>A thread interruption ignored because a thread was not alive
 * at the time of the interrupt will be reflected by this method
 * returning false.
 *
 * @return  <code>true</code> if the current thread has been interrupted;
 *          <code>false</code> otherwise.
 * @see #isInterrupted()
 * @revised 6.0
 */
```

åŒæ—¶åœ¨æŠ›å‡º`InterruptedException` ä¹‹åä¸­æ–­çŠ¶æ€ä¹Ÿä¼šè¢«è‡ªåŠ¨æ¸…é™¤ä¸ºfalse

> if any thread has interrupted the current thread. The <i>interrupted status</i> of the current thread is cleared when this exception is thrown.     ----Thread.sleepæ³¨é‡Š

## 10.Yieldæ–¹æ³•

Thread.yield()æ–¹æ³•çš„ä½œç”¨ï¼šæš‚åœå½“å‰æ­£åœ¨æ‰§è¡Œçš„çº¿ç¨‹ï¼Œå¹¶æ‰§è¡Œå…¶ä»–çº¿ç¨‹ã€‚ï¼ˆå¯èƒ½æ²¡æœ‰æ•ˆæœï¼‰
yield()è®©å½“å‰æ­£åœ¨è¿è¡Œçš„çº¿ç¨‹å›åˆ°å¯è¿è¡ŒçŠ¶æ€ï¼Œä»¥å…è®¸å…·æœ‰ç›¸åŒä¼˜å…ˆçº§çš„å…¶ä»–çº¿ç¨‹è·å¾—è¿è¡Œçš„æœºä¼šã€‚å› æ­¤ï¼Œä½¿ç”¨yield()çš„ç›®çš„æ˜¯è®©å…·æœ‰ç›¸åŒä¼˜å…ˆçº§çš„çº¿ç¨‹ä¹‹é—´èƒ½å¤Ÿé€‚å½“çš„è½®æ¢æ‰§è¡Œã€‚ä½†æ˜¯ï¼Œå®é™…ä¸­æ— æ³•ä¿è¯yield()è¾¾åˆ°è®©æ­¥çš„ç›®çš„ï¼Œå› ä¸ºï¼Œè®©æ­¥çš„çº¿ç¨‹å¯èƒ½è¢«çº¿ç¨‹è°ƒåº¦ç¨‹åºå†æ¬¡é€‰ä¸­ã€‚
ç»“è®ºï¼šå¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œyield()å°†å¯¼è‡´çº¿ç¨‹ä»è¿è¡ŒçŠ¶æ€è½¬åˆ°å¯è¿è¡ŒçŠ¶æ€ï¼Œä½†æœ‰å¯èƒ½æ²¡æœ‰æ•ˆæœã€‚

## 11.Synchronizedå…³é”®å­— 

### çº¿ç¨‹å®‰å…¨é—®é¢˜

```java
public class TicketRunnable implements Runnable {
    
    private final static int MAX_NO = 500;

    private int index = 1;

    @Override
    public void run() {
        while (true) {
                if (index > MAX_NO) {
                    return;
                }
                try {
                    Thread.sleep(5);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "ç¬¬ï¼š" + index++);
        }
    }
}
```

ç”¨è¿™ä¸ªåˆ›å»ºå¤šä¸ª`Thread`ç„¶åè¿è¡Œ

> äºŒå·çª—å£ç¬¬ï¼š497
> ä¸‰å·çª—å£ç¬¬ï¼š499
> ä¸€å·çª—å£ç¬¬ï¼š498
> ä¸€å·çª—å£ç¬¬ï¼š500
> äºŒå·çª—å£ç¬¬ï¼š`502`
> ä¸‰å·çª—å£ç¬¬ï¼š`501`

å¯ä»¥çœ‹å‡ºæ‰“å°å‡ºäº†501ï¼Œ502æ˜æ˜¾ä¸å¯¹ä¸ºä»€ä¹ˆä¼šå‡ºç°è¿™ç§é—®é¢˜å‘¢ï¼Ÿå…¶å®ä»”ç»†æƒ³æƒ³ä¹Ÿå¾ˆå®¹æ˜“ç†è§£

![mark](http://static.imlgw.top///20190326/zSGNeiCW2zc1.png?imageslim)

å½“ä¸¤ä¸ªçº¿ç¨‹å¦‚å›¾æ‰€ç¤ºçš„æƒ…å†µï¼Œ2å·çº¿ç¨‹`index=500`ç„¶å`index++`ç„¶å 1å·çº¿ç¨‹è¯»å–åˆ°`index`çš„å€¼å°±ä¼šäº§ç”Ÿè¿™ä¸ªé—®é¢˜ã€‚

### åŒæ­¥ä»£ç å—

**è§£å†³çº¿ç¨‹å®‰å…¨é—®é¢˜**

```java
public class TicketRunnable implements Runnable {

    private final static int MAX_NO = 500;
    
    private int index = 1;

    private final Object MONITOR = new Object();

    @Override
    public void run() {
        while (true) {
            synchronized (MONITOR) {
                //å•çº¿ç¨‹
                if (index > MAX_NO) {
                    return;
                }
                try {
                    Thread.sleep(5);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "ç¬¬ï¼š" + index++);
            }
        }
    }
}
```

åˆ©ç”¨`MONITOR`å¯¹è±¡ä½œä¸ºåŒæ­¥é”åŒæ­¥ä¹‹åçš„éƒ¨åˆ†å°±ç›¸å½“äºå•çº¿ç¨‹ï¼Œ`MONITOR`é”å¯¹è±¡ä¸€èˆ¬è®¾ç½®ä¸º`final`çš„é¿å…åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­å¯¹`MONITOR`å¯¹è±¡è¿›è¡Œæ”¹å˜è€Œäº§ç”Ÿæ— æ³•é¢„æ–™çš„åæœ

### åŒæ­¥æ–¹æ³•

```java
public class SynchronizeRunnable implements Runnable {

    private final static int MAX_NO = 500;

    private int index = 1;

    @Override
    public  void run() {
        //thisé”
        while (true) {
            if (ticket()) {
                return;
            }

        }
    }

    private synchronized boolean ticket(){
        //synchronized (this) {
            //1.getFiled
            if (index > MAX_NO) {
                return true;
            }
            try {
                Thread.sleep(5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            // getFiled index
            // index=index+1
            // putFiled index
            //åŒæ­¥ä»£ç å—å°±æ˜¯ä¿æŠ¤å…±äº«æ•°æ®index, MAX_NOä¸æ˜¯,ä»–æ˜¯åªè¯»æ•°æ®
            System.out.println(Thread.currentThread().getName() + "ç¬¬ï¼š" + index++);
            return false;
       // }
    }
}
```

é»˜è®¤åŠ çš„æ˜¯`this`é”

**è¯æ˜thisé”çš„å­˜åœ¨**

```java
public class SynchronizedThis {
    public static void main(String[] args) {
        ThisLock thisLock = new ThisLock();
        Thread thread = new Thread(() -> thisLock.m1(), "Thread0");
        thread.start();
        Thread thread1 = new Thread(() -> thisLock.m2(), "Thread1");
        thread1.start();
        Thread thread2 = new Thread(() -> thisLock.m3(), "Thread2");
        thread2.start();
    }
}

class ThisLock {

    private final Object LOCK = new Object();

    public synchronized void m1() {
        System.out.println(Thread.currentThread().getName());
        try {
            Thread.sleep(10_000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public synchronized void m2() {
        System.out.println(Thread.currentThread().getName());
        try {
            Thread.sleep(10_000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void m3() {
        synchronized (LOCK) {
            System.out.println(Thread.currentThread().getName());
            try {
                Thread.sleep(10_000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

è¿è¡Œä¸Šé¢çš„ä»£ç ä¼šå‘ç°`Thread0`å’Œ`Thread2`ä¼šå…ˆæ‰“å°å‡ºæ¥å› ä¸ºä»–ä»¬ä¸æ˜¯åŒä¸€ä¸ªé”ä¸ç”¨ç­‰å¾…å¯¹æ–¹ï¼Œè€Œ`Thread1`ä¼šç­‰å¾…ä¸€æ®µæ—¶é—´åæ‰ä¼šæ‰§è¡Œå› ä¸ºå®ƒéœ€è¦ç­‰å¾…`Thread0`é‡Šæ”¾é”è€Œè¿™ä¸ªé”åªèƒ½æ˜¯`thisé”`

**è¯æ˜classé”çš„å­˜åœ¨**

```java
public class SynchronizedClass {
    public static void main(String[] args) {
        Thread thread0 = new Thread(() -> ClassLock.m1(), "Thread0");
        thread0.start();
        Thread thread1 = new Thread(() -> ClassLock.m2(), "Thread1");
        thread1.start();
        Thread thread2 = new Thread(() -> ClassLock.m3(), "Thread2");
        thread2.start();
    }
}

class ClassLock {
    static {
        synchronized (ClassLock.class) {
            System.out.println("static" + Thread.currentThread().getName());
            try {
                Thread.sleep(10_000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static synchronized void m1() {
        System.out.println(Thread.currentThread().getName());
        try {
            Thread.sleep(10_000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static synchronized void m2() {
        System.out.println(Thread.currentThread().getName());
        try {
            Thread.sleep(10_000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void m3() {
        System.out.println(Thread.currentThread().getName());
        try {
            Thread.sleep(10_000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

è¿è¡Œä¸Šé¢çš„ä»£ç ä¼šå‘ç°æœ€å¼€å§‹åªæœ‰ä¸€ä¸ªçº¿ç¨‹ä¼šå»æ‰§è¡Œé™æ€ä»£ç å¿«ï¼Œåœ¨é™æ€ä»£ç å¿«æ‰§è¡Œå®Œä¹‹å`Thread2`ä¼šå’Œå¦ä¸€ä¸ªçº¿ç¨‹ä¸€èµ·æ‰§è¡Œï¼Œè¯´æ˜ä¸€å¼€å§‹`Thread2`å›å’Œå…¶ä¸­ä¸€ä¸ªçº¿ç¨‹æŠ¢`Classé”`æ‰§è¡Œé™æ€ä»£ç å—ï¼ˆé™æ€ä»£ç å—åªä¼šæ‰§è¡Œä¸€æ¬¡ï¼‰

### æ­»é”

> ä¸€ä¸ªçº¿ç¨‹å¯ä»¥æŒæœ‰å¤šä¸ªé”ï¼Œè€Œè¿™æ ·å°±å¯èƒ½ä¼šå¯¼è‡´`æ­»é”`çš„äº§ç”Ÿ

**æ­»é”ç¤ºä¾‹**

```java
public class Service1 {
    private  final Object LOCK=new Object();

    private Service2 service2;

    public  void s1(){
        synchronized (LOCK){
            System.out.println("s1==============");
        }
    }

    public void s2(){
        synchronized (LOCK){
            System.out.println("s2==============");
            service2.m2();
        }
    }

    public void setService2(Service2 service2) {
        this.service2 = service2;
    }
}
---------------------------------------------------
public class Service2 {
    private Service1 service1;

    public Service2(Service1 service1) {
        this.service1 = service1;
    }

    private  final  Object LOCK=new Object();

    public  void  m1(){
        synchronized (LOCK){
            System.out.println("m1");
            service1.s1();
        }
    }

    public  void  m2(){
        synchronized (LOCK){
            System.out.println("m2");
        }
    }
}
-------------------------------------------------
public class DeadLockTest {
    public static void main(String[] args) {
        Service1 service1=new Service1();
        Service2 service2 =new Service2(service1);
        service1.setService2(service2);

        new Thread(()->{
            while (true){
                service2.m1();
            }
        }).start();

        new Thread(()->{
            while (true){
                service1.s2();
            }
        }).start();
    }
}
```

æ‰§è¡Œä¸Šé¢ä»£ç å°±ä¼šå‘ç°åœ¨è¿è¡Œä¸€æ®µæ—¶é—´åä¸¤ä¸ªçº¿ç¨‹éƒ½`é˜»å¡`äº†ï¼Œè¿™å°±æ˜¯`æ­»é”`

- `jps`&`jstack`  åˆ†ææ­»é”

![mark](http://static.imlgw.top///20190328/BG9eU9Rq8ae0.png?imageslim)

ä¸¤ä¸ªçº¿ç¨‹éƒ½éœ€è¦å¯¹æ–¹æ‰‹ä¸Šçš„çš„é”ï¼Œé™·å…¥åƒµæŒçŠ¶æ€ï¼Œå°±ä¼šäº§ç”Ÿæ­»é”ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨`jconsole`å›¾å½¢åŒ–ç•Œé¢æ¥åˆ†æ

## 12.çº¿ç¨‹é—´é€šè®¯

åœ¨Javaå¹³å°ä¸­ï¼ŒObject.wait()/notify() ç­‰æ–¹æ³•å¯ç”¨äºå®ç°çº¿ç¨‹çš„ç­‰å¾…å’Œé€šçŸ¥ï¼Œwaitå°†å½“å‰çº¿ç¨‹æš‚åœç”Ÿå‘½å‘¨æœŸå˜ä¸º **WAITING** ï¼Œè€Œnotify() åˆ™å¯ä»¥å”¤é†’ä¸€ä¸ªè¢«æš‚åœçš„çº¿ç¨‹ä»è€Œå®ç°é€šçŸ¥ï¼Œä¸€èˆ¬æ¥è¯´wait() ä»£ç æ¨¡æ¿ç±»ä¼¼ä¸‹é¢

```java
synchronized(someObj){
    while(ä¿æŠ¤æ¡ä»¶ä¸æˆç«‹){
        //ç­‰å¾…
        someObj.wait();
    }
    //ä¿æŠ¤æ¡ä»¶æ»¡è¶³
    doAction();
}
```

è€Œ`notify()` å¯¹åº”ä»£ç æ¨¡æ¿å¦‚ä¸‹

```java
synchronized(someObj){
    //æ›´æ–°ç­‰å¾…çº¿ç¨‹çš„ä¿æŠ¤æ¡ä»¶è®¾è®¡çš„å…±äº«å˜é‡
    updateSharedDate();
    //å”¤é†’å…¶ä»–çº¿ç¨‹
    someObj,notify();
}
```

### ç”Ÿäº§è€…æ¶ˆè´¹è€…æ¨¡å‹

**é”™è¯¯ç¤ºä¾‹**

```java
public class ProduceConsumerVersion1 {
    public static void main(String[] args) {
        ProduceConsumerVersion1 pc = new ProduceConsumerVersion1();
        new Thread(() -> {
            while (true) {
                pc.produce();
            }
        }, "Produce").start();
        new Thread(() -> {
            while (true) {
                pc.consumer();
            }
        }, "Consumer").start();
    }

    private int i = 0;

    private final Object LOCK = new Object();

    public void produce() {
        synchronized (LOCK) {
            System.out.println("Produce->" + (i++));
        }
    }

    public void consumer() {
        synchronized (LOCK) {
            System.out.println("Consumer->" + (i));
        }
    }
}
```

è¿™ç§æ¨¡å‹å½“ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…å¯åŠ¨åä¼šå‘ç°ä¸¤ä¸ªçº¿ç¨‹æ— æ³•åä½œï¼Œç”Ÿäº§è€…ä¸æ–­ç”Ÿäº§ï¼Œæ¶ˆè´¹è€…`ä¸æ¶ˆè´¹`æˆ–è€…`é‡å¤æ¶ˆè´¹`

**å•ç”Ÿäº§è€…&å•æ¶ˆè´¹è€…**

```java
public class ProduceConsumerVersion2 {
    public static void main(String[] args) {
        ProduceConsumerVersion2 pc = new ProduceConsumerVersion2();
        Stream.of("Produce1").forEach(n -> {
            new Thread(() -> {
                while (true) {
                    pc.produce();
                }
            }, n).start();
        });
        Stream.of("Consumer1").forEach(n -> {
            new Thread(() -> {
                while (true) {
                    pc.consumer();
                }
            }, n).start();
        });
    }

    private int i = 0;

    private final Object LOCK = new Object();

    private volatile boolean isProduced = false;

    public void produce() {
        synchronized (LOCK) {
            if (isProduced) {
                //å·²ç»ç”Ÿäº§äº†
                try {
                    LOCK.wait();//ç­‰å¾…æ¶ˆè´¹è€…å”¤é†’
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(Thread.currentThread().getName() + "-->" + (++i));//produce
            isProduced = true;
            LOCK.notify();
        }
    }

    public void consumer() {
        synchronized (LOCK) {
            if (!isProduced) {
                try {
                    LOCK.wait();//ç­‰å¾…ç”Ÿäº§è€…å”¤é†’
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(Thread.currentThread().getName() + "-->" + (i));//consumer
            isProduced = false;
            LOCK.notify();
        }
    }
}
```

**wait()ï¼š** å½“å‰çº¿ç¨‹`é‡Šæ”¾é”`è¿›å…¥è¯¥é”å¯¹è±¡çš„`ç­‰å¾…é˜Ÿåˆ—` 

> Causes the current thread to wait until another thread invokes the
>
> {@link java.lang.Object#notify()} method or the
>
> {@link java.lang.Object#notifyAll()} method for this object.
>
> In other words, this method behaves exactly as if it simply
>
> performs the call {@code `wait(0)`}.
>
> The current thread `must own this object's monitor.` The thread
>
> `releases` ownership of this monitor and waits until another thread
>
> notifies threads waiting on this object's monitor to wake up
>
> either through a call to the {@code notify} method or the
>
> {@code notifyAll} method. The thread then waits until it can
>
> re-obtain ownership of the monitor and resumes execution.

**wait(long timeout)ï¼š**`wait()`çš„é‡è½½æ–¹æ³•å¾ˆå®¹æ˜“æƒ³åˆ°æ˜¯å¹²å•¥çš„âœ”

> Causes the current thread to wait until either another thread invokes the
>
> {@link java.lang.Object#notify()} method or the
>
> {@link java.lang.Object#notifyAll()} method for this object, or a
>
> `specified amount of time has elapsed.`
>
> The current thread must own this object's monitor.
>
> @throws  `IllegalArgumentException`  if the value of timeout is negative.

**notify()ï¼š** å”¤é†’è¯¥`é”å¯¹è±¡`çš„`ç­‰å¾…é˜Ÿåˆ—`çš„çº¿ç¨‹ï¼Œå”¤é†’æ–¹æ³•ä¸åŒçš„è™šæ‹Ÿæœºå®ç°ä¸åŒæœ‰çš„å¯èƒ½æ˜¯`FCFS`æœ‰çš„å¯èƒ½æ˜¯`SJF` ç­‰ç­‰....æ‰€ä»¥å”¤é†’çš„æ˜¯é‚£ä¸ªçº¿ç¨‹æ˜¯æ— æ³•ç¡®å®šçš„

> Wakes up a single thread that is `waiting on this object's`
>
> `monitor`. If any threads are waiting on this object, one of them
>
> is chosen to be awakened. `The choice is arbitrary and occurs at`
>
> `the discretion of the implementation`. A thread waits on an object's
>
> monitor by calling one of the {@code wait} methods.
>
> The awakened thread will not be able to proceed until the current
>
> thread `relinquishes` the lock on this object. The awakened thread will
>
> compete in the usual manner with any other threads that might be
>
> actively competing to synchronize on this object; for example, the
>
> awakened thread enjoys no reliable privilege or disadvantage in being
>
> the next thread to lock this object.

ç”Ÿäº§è€…ç”Ÿäº§ä¸€ä¸ªæ¶ˆè´¹è€…æ¶ˆè´¹ä¸€ä¸ªï¼Œæ²¡æ¯›ç—…ï¼Œä½†æ˜¯ä¸Šé¢çš„ä»£ç ä»…ä»…é€‚ç”¨äº`å•ç”Ÿäº§è€…&æ¶ˆè´¹è€…`å¯¹äºå¤šä¸ªç”Ÿäº§è€…æ¶ˆè´¹è€…å°±ä¼šæœ‰çº¿ç¨‹å®‰å…¨é—®é¢˜ï¼Œå…·ä½“é—®é¢˜å¦‚ä¸‹

**æµ‹è¯•å¤šæ¶ˆè´¹è€…&ç”Ÿäº§è€…**

æ²¿ç”¨ä¸Šé¢single p&cçš„ä»£ç ï¼Œæµ‹è¯•å¤šæ¶ˆè´¹è€…å’Œç”Ÿäº§è€…

```java
    public static void main(String[] args) {
        ProduceConsumerVersion3 pc = new ProduceConsumerVersion3();
        Stream.of("Produce1", "Produce2", "Produce3", "Produce4").forEach(n -> {
            new Thread(() -> {
                while (true) {
                    pc.produce();
                }
            }, n).start();
        });
        Stream.of("Consumer1", "Consumer2", "Consumer3").forEach(n -> {
            new Thread(() -> {
                while (true) {
                    pc.consumer();
                }
            }, n).start();
        });
    }
```

è¿è¡Œä¼šå‘ç°ç¨‹åºè¿›å…¥`â€æ­»é”â€œ`çŠ¶æ€ï¼Œç”¨`jps&jstack`åˆ†æ

![mark](http://static.imlgw.top///20190328/pzXBY0ertEVV.png?imageslim)

ç¨‹åºå¹¶æ²¡æœ‰å‘ç°æ­»é”âï¼Œè¿™å°±æ˜¯å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…ä¼šäº§ç”Ÿçš„`å‡æ­»`çŠ¶æ€ï¼Œå®é™…ä¸Šæ˜¯æ‰€æœ‰çš„çº¿ç¨‹éƒ½è¿›å…¥äº†`wait()`çŠ¶æ€éƒ½æ”¾å¼ƒäº†`CPU`çš„æ‰§è¡Œæƒ

**å‡æ­»åŸå› åˆ†æ**

```java
Produce1-->1	notify C1 wait
Consumer1-->1	notify P1 wait
Produce1-->2    notify C2 wait
Consumer2-->2   notify P2 wait
Produce2-->3	notify P1 wait ---> Produce1-->wait
```

ä¸Šé¢æ˜¯å…¶ä¸­ä¸€ç§æƒ…å†µï¼Œå¤§è‡´åˆ†æä¸‹ï¼šå‰ä¸¤æ¬¡ç”Ÿäº§æ¶ˆè´¹éƒ½æ­£å¸¸ä¸€ä¸ª`æ¶ˆè´¹è€…`å”¤é†’ä¸€ä¸ª`ç”Ÿäº§è€…`ï¼Œå‰ä¸¤æ¬¡æ‰§è¡Œå®Œä¹‹å`P1 C1 C2`éƒ½è¿›å…¥`wait`çŠ¶æ€ç„¶åç¬¬ä¸‰æ¬¡ç”Ÿäº§çš„æ—¶å€™`P2`å”¤é†’äº†ä¸€ä¸ªä¸è¯¥å”¤é†’çš„äººğŸ˜‚ å”¤é†’äº†`P1`ç„¶å`wait`äº†ï¼Œ`P1`é†’æ¥åå‘ç°å·²ç»ç”Ÿäº§äº†ç„¶åä¹Ÿ`wait`å»äº†ï¼Œè‡³æ­¤æ‰€æœ‰çš„çº¿ç¨‹å…¨éƒ¨è¿›å…¥`wait`çŠ¶æ€å°±é€ æˆäº†å‡æ­»ã€‚è¿™ä¸ªé—®é¢˜è®°å¾—å¤§ä¸€çš„æ—¶å€™è¿˜é—®è¿‡è€å¸ˆå½“æ—¶ç‰¹åˆ«çº ç»“ä¸ºå•¥ä¼šæ­»é”ï¼Œç°åœ¨çœ‹çœ‹å…¶å®ä¹Ÿæ²¡å•¥ï¼Œä¸»è¦å°±æ˜¯`notify`å”¤é†’çš„çº¿ç¨‹æ˜¯ä¸ç¡®å®šçš„ï¼Œæ˜¯ç”±`JVM`å†³å®šçš„æ¯ç§`JDK`çš„å®ç°ä¹Ÿä¸å¤ªä¸€æ ·ï¼Œæ— æ³•ä¿è¯æ¶ˆè´¹è€…ä¸€å®šå”¤é†’ç”Ÿäº§è€…ï¼Œåä¹‹äº¦ç„¶ã€‚

**å¤šç”Ÿäº§è€…&å¤šæ¶ˆè´¹è€…**

```java
import java.util.stream.Stream;
public class ProduceConsumerVersion3 {
    public static void main(String[] args) {
        ProduceConsumerVersion3 pc = new ProduceConsumerVersion3();
        Stream.of("Produce1", "Produce2", "Produce3", "Produce4").forEach(n -> {
            new Thread(() -> {
                while (true) {
                    pc.produce();
                }
            }, n).start();
        });
        Stream.of("Consumer1", "Consumer2", "Consumer3").forEach(n -> {
            new Thread(() -> {
                while (true) {
                    pc.consumer();
                }
            }, n).start();
        });
    }

    private int i = 0;

    private final Object LOCK = new Object();

    private volatile boolean isProduced = false;

    public void produce() {
        synchronized (LOCK) {
            while (isProduced) {
                //å·²ç»ç”Ÿäº§äº†
                try {
                    LOCK.wait(); //åŠ å…¥LOCKé”çš„waité˜Ÿåˆ—
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(Thread.currentThread().getName() + "-->" + (++i));//produce
            isProduced = true;
            LOCK.notifyAll();
        }
    }

    public void consumer() {
        synchronized (LOCK) {
            while (!isProduced) {
                try {
                    LOCK.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(Thread.currentThread().getName() + "-->" + (i));//consumer
            isProduced = false;
            LOCK.notifyAll();
        }
    }
}
```

**notifyAll()ï¼š**å”¤é†’å½“å‰é”å¯¹è±¡ç­‰å¾…é˜Ÿåˆ—ä¸Šçš„`æ‰€æœ‰`çº¿ç¨‹

> Wakes up `all threads` that are waiting on `this object's monitor`. A
>
> thread waits on an object's monitor by calling one of the
>
> {@code wait} methods.
>
> The awakened threads will not be able to proceed until the current
>
> thread relinquishes the lock on this object. The awakened threads
>
> will `compete in the usual manner` with any other threads that might
>
> be actively competing to synchronize on this object; for example,
>
> the awakened threads enjoy `no reliable privilege or disadvantage` in
>
> being the next thread to lock this object.

â‘  ä¸ºäº†è§£å†³ä¸Šé¢çš„`å‡æ­»`é—®é¢˜è¿™é‡Œä½¿ç”¨äº†`notifyAll()`æ¥å”¤é†’`ç­‰å¾…é˜Ÿåˆ—`çš„çº¿ç¨‹ï¼Œçœ‹åå­—å°±çŸ¥é“è¿™ä¸ªæ–¹æ³•ä¼šå”¤é†’æ‰€æœ‰çš„çº¿ç¨‹ï¼Œé‚£ä¹ˆä¸Šé¢çš„å‡æ­»é—®é¢˜å°±è‡ªç„¶è§£å†³äº†ã€‚

â‘¡ è¿˜æœ‰ä¸€ç‚¹ä¸åŒçš„æ˜¯è¿™é‡Œåˆ¤æ–­ç”Ÿäº§çŠ¶æ€æ—¶ç”¨çš„æ˜¯`while`è€Œä¸æ˜¯`if`ä¸ºä»€ä¹ˆä¸ç”¨`if`? å…¶å®ä¹Ÿå¾ˆå¥½ç†è§£å¦‚æœæœ‰å¤šä¸ªç”Ÿäº§è€…æˆ–è€…æ¶ˆè´¹è€…åŒæ—¶åœ¨`ç­‰å¾…é˜Ÿåˆ—`ä¸­ï¼Œç„¶åå…¶ä¸­ä¸€ä¸ªæŠ¢åˆ°é”åæ‰§è¡Œï¼Œæ‰§è¡Œå®Œç”Ÿäº§åå”¤é†’äº†æ‰€æœ‰ç­‰å¾…çš„çº¿ç¨‹ï¼Œå‡è®¾å”¤é†’çš„æ˜¯`ç”Ÿäº§è€…`çš„è¯ï¼Œå› ä¸ºæ˜¯`ifè¯­å¥`æ§åˆ¶çš„è¢«å”¤é†’çš„ç”Ÿäº§è€…æŠ¢åˆ°é”ä¹‹åå°±ç›´æ¥é¡ºç€æ‰§è¡Œä¸‹å»äº†ï¼Œå°±ç›´æ¥å»ç”Ÿäº§äº†ï¼Œå°±ä¼šé€ æˆ`é‡å¤çš„ç”Ÿäº§`å½“ç„¶ç”¨`else`è¯­å¥è²Œä¼¼å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½†æ˜¯é‚£ä¼šå½±å“æ•ˆç‡ï¼ˆä¸ªäººæ„Ÿè§‰ï¼‰ï¼Œè€Œä¸”å¾ˆåˆ«æ‰­ï¼ˆè¢«å”¤é†’äº†ç›´æ¥é€€å‡ºï¼Ÿï¼Ÿï¼Ÿï¼‰. æ‰€ä»¥è¿™é‡Œç”¨`while`æ¥è¿›è¡Œ`äºŒæ¬¡æ£€æµ‹`é¿å…è¿™ç§æƒ…å†µï¼Œè¿™ç§whileå¾ªç¯ä¹Ÿè¢«ç§°ä¸º`è‡ªæ—‹é”` è¿™ä¸€å—åé¢çš„æ–‡ç« ä¼šå†è¯¦ç»†çš„è®²ã€‚

### ä¸ºä»€ä¹ˆwaitå’Œnotifyå¿…é¡»åœ¨åŒæ­¥æ–¹æ³•æˆ–åŒæ­¥å—ä¸­è°ƒç”¨ï¼Ÿ 

è¿™æ˜¯`é˜¿é‡Œå·´å·´`çš„ä¸€é“é¢è¯•é¢˜

â‘  é¦–å…ˆä»è¯­æ³•å±‚é¢è®²ï¼Œå¦‚æœä¸åœ¨åŒæ­¥æ–¹æ³•å’ŒåŒæ­¥ä»£ç å—ä¸­è°ƒç”¨ï¼Œä¹Ÿå°±æ˜¯è¯´æ²¡æœ‰åŠ é”ï¼Œè‡ªç„¶å°±ä¸ç”¨è°ˆæ˜¯ä¸æ˜¯`é”å¯¹è±¡çš„æŒæœ‰è€…` ï¼Œå°±ä¼šæŠ¥`IllegalMonitorStateException`.

> @throws  `IllegalMonitorStateException`  if the current thread is not
>
> the owner of the object's monitor.

â‘¡è®¾æƒ³ä¸‹å¦‚æœä¸åŠ é”å¯ä»¥ç›´æ¥è°ƒç”¨ï¼Œå°±ä¼šäº§ç”Ÿæ‰€è°“çš„`ç«æ€æ¡ä»¶`ï¼Œå‡è®¾`wait()`,`notify()`,`notifyAll()`æ–¹æ³•ä¸éœ€è¦åŠ é”å°±èƒ½å¤Ÿè¢«è°ƒç”¨ã€‚æ­¤æ—¶æ¶ˆè´¹è€…çº¿ç¨‹è°ƒç”¨`wait()`æ­£åœ¨è¿›å…¥çŠ¶æ€å˜é‡çš„ç­‰å¾…é˜Ÿåˆ—(è¯‘è€…æ³¨:å¯èƒ½è¿˜æœªè¿›å…¥)ã€‚åœ¨åŒä¸€æ—¶åˆ»ï¼Œç”Ÿäº§è€…çº¿ç¨‹è°ƒç”¨`notify()`æ–¹æ³•æ‰“ç®—å‘æ¶ˆè´¹è€…çº¿ç¨‹é€šçŸ¥çŠ¶æ€æ”¹å˜ã€‚é‚£ä¹ˆæ­¤æ—¶æ¶ˆè´¹è€…çº¿ç¨‹å°†é”™è¿‡è¿™ä¸ªé€šçŸ¥å¹¶ä¸€ç›´é˜»å¡ã€‚å› æ­¤ï¼Œå¯¹è±¡çš„`wait()`,`notify()`,`notifyAll()`æ–¹æ³•å¿…é¡»åœ¨è¯¥å¯¹è±¡çš„åŒæ­¥æ–¹æ³•æˆ–åŒæ­¥ä»£ç å—ä¸­è¢«äº’æ–¥åœ°è°ƒç”¨ã€‚

> è®¡ç®—çš„æ­£ç¡®æ€§å–å†³äºå¤šä¸ªçº¿ç¨‹çš„äº¤æ›¿æ‰§è¡Œæ—¶åºæ—¶å°±ä¼šäº§ç”Ÿç«æ€æ¡ä»¶

### wait()åè¢«å”¤é†’ä¼šæ€ä¹ˆæ ·ï¼Ÿ

ä¸Šé¢è¯´åˆ°è¢«å”¤é†’åä¼šå»æŠ¢é”ï¼Œä½†æ˜¯è¿™é‡Œæœ‰äººå¯èƒ½ä¼šæœ‰ç–‘é—®ï¼Œå»æŠ¢é”ä¼šä¸ä¼šå›åˆ°åŒæ­¥çš„èµ·ç‚¹å»äº‰æŠ¢é”ï¼Œç„¶åæŠŠwaitå‰çš„é€»è¾‘å†æ‰§è¡Œä¸€éï¼Ÿè¿™é‡Œè‚¯å®šäº‹ä¸ä¼šçš„ï¼Œç¡®å®æ˜¯è¦æŠ¢é”ä½†æ˜¯ä¼šæœ‰è®°å½•ä¼šç»§ç»­é¡ºç€waitæ–¹æ³•èµ°ä¸‹å»ã€‚

### notifyå’Œä¸­æ–­çš„ä¸€ä¸ªå¾ˆæœ‰æ„æ€çš„ç°è±¡

```java
public class NotifyInter {

    volatile int a = 0;

    public static void main(String[] args) {

        Object object = new Object();

        NotifyInter waitNotify = new NotifyInter();

        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {

                synchronized (object) {
                    System.out.println("çº¿ç¨‹1 è·å–åˆ°ç›‘è§†å™¨é”");
                    try {
                        object.wait();
                        System.out.println("çº¿ç¨‹1 æ­£å¸¸æ¢å¤å•¦ã€‚ä½†æ˜¯ isInterrupt = "+ Thread.currentThread().isInterrupted());
                    } catch (InterruptedException e) {
                        System.out.println("çº¿ç¨‹1 waitæ–¹æ³•æŠ›å‡ºäº†InterruptedExceptionå¼‚å¸¸");
                    }
                }
            }
        }, "çº¿ç¨‹1");
        thread1.start();

        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {

                synchronized (object) {
                    System.out.println("çº¿ç¨‹2 è·å–åˆ°ç›‘è§†å™¨é”");
                    try {
                        object.wait();
                        System.out.println("çº¿ç¨‹2 æ­£å¸¸æ¢å¤å•¦ã€‚");
                    } catch (InterruptedException e) {
                        System.out.println("çº¿ç¨‹2 waitæ–¹æ³•æŠ›å‡ºäº†InterruptedExceptionå¼‚å¸¸");
                    }
                }
            }
        }, "çº¿ç¨‹2");
        thread2.start();

        // è¿™é‡Œè®© thread1 å’Œ thread2 å…ˆèµ·æ¥ï¼Œç„¶åå†èµ·åé¢çš„ thread3
       try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
        }

        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (object) {
                    System.out.println("çº¿ç¨‹3 æ‹¿åˆ°äº†ç›‘è§†å™¨é”ã€‚");
                    System.out.println("çº¿ç¨‹3 è®¾ç½®çº¿ç¨‹1ä¸­æ–­");
                    thread1.interrupt(); // 1
                    //waitNotify.a = 1; // è¿™è¡Œæ˜¯ä¸ºäº†ç¦æ­¢ä¸Šä¸‹çš„ä¸¤è¡Œä¸­æ–­å’Œnotifyä»£ç é‡æ’åº
                    System.out.println("çº¿ç¨‹3 è°ƒç”¨notify");
                    object.notify(); //2
                    System.out.println("çº¿ç¨‹3 è°ƒç”¨å®Œnotifyåï¼Œä¼‘æ¯ä¸€ä¼š");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                    }
                    System.out.println("çº¿ç¨‹3 ä¼‘æ¯å¤Ÿäº†ï¼Œç»“æŸåŒæ­¥ä»£ç å—");
                }
            }
        }, "çº¿ç¨‹3").start();
    }
}
```

å¤šæ‰§è¡Œå‡ æ¬¡å¯èƒ½å°±å¯èƒ½ä¼šå‘ç”Ÿå¦‚ä¸‹æƒ…å†µï¼Œçº¿ç¨‹1è¢«æ‰“æ–­åå±…ç„¶æ­£å¸¸çš„è¿”å›äº†ï¼ï¼ï¼ï¼çº¿ç¨‹2è¢«é˜»å¡ä½äº†

```java
çº¿ç¨‹1 è·å–åˆ°ç›‘è§†å™¨é”
çº¿ç¨‹2 è·å–åˆ°ç›‘è§†å™¨é”
çº¿ç¨‹3 æ‹¿åˆ°äº†ç›‘è§†å™¨é”ã€‚
çº¿ç¨‹3 è®¾ç½®çº¿ç¨‹1ä¸­æ–­
çº¿ç¨‹3 è°ƒç”¨notify
çº¿ç¨‹3 è°ƒç”¨å®Œnotifyåï¼Œä¼‘æ¯ä¸€ä¼š
çº¿ç¨‹3 ä¼‘æ¯å¤Ÿäº†ï¼Œç»“æŸåŒæ­¥ä»£ç å—
çº¿ç¨‹1 æ­£å¸¸æ¢å¤å•¦ã€‚ä½†æ˜¯ isInterrupt = true
```

å…¶å®è¿™é‡Œä¸»è¦é—®é¢˜å°±æ˜¯ `notify()` å’Œ`interrupt()` æ‰§è¡Œé¡ºåºçš„é—®é¢˜

- å¦‚æœå…ˆè¢«æ‰“æ–­ï¼Œé‚£ä¹ˆåç»­çš„notifyä¼šè¿™ä¸ªçº¿ç¨‹æ— æ•ˆï¼Œä¾ç„¶ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œå¦‚æœè¿™æ˜¯è¯¥é”å®ä¾‹ä¸Šä»ç„¶æœ‰å…¶ä»–çº¿ç¨‹å¤„äºwaitçŠ¶æ€ï¼Œé‚£ä¹ˆè¿™ä¸ªnotifyä¼šå”¤é†’å…¶ä¸­çš„ä¸€ä¸ªï¼Œä¸èƒ½è™šå‘ï¼Œå…·ä½“å¯ä»¥å‚è€ƒ [Javaè¯­è¨€è§„èŒƒæ–‡æ¡£17.2.4](https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.2.4)

  > The above specifications allow us to determine several properties having to do with the interaction of waits, notification, and interruption.
  >
  > If a thread is both notified and interrupted while waiting, it may either:
  >
  > - return normally from `wait`, while still having a pending interrupt (in other words, a call to `Thread.interrupted` would return true)
  > - return from `wait` by throwing an `InterruptedException`
  >
  > The thread may not reset its interrupt status and return normally from the call to `wait`.
  >
  > Similarly, notifications cannot be lost due to interrupts. Assume that a set *s* of threads is in the wait set of an object *m*, and another thread performs a `notify` on *m*. Then either:
  >
  > - at least one thread in *s* must return normally from `wait`, or
  > - all of the threads in *s* must exit `wait` by throwing `InterruptedException`
  >
  > Note that if a thread is both interrupted and woken via `notify`, and that thread returns from `wait` by throwing an `InterruptedException`, then some other thread in the wait set must be notified.

- å¦‚æœå…ˆè¢«notify()ï¼Œé‚£ä¹ˆçº¿ç¨‹ä¼šä»waitä¸­é†’æ¥ï¼Œç„¶åä¸­æ–­ï¼Œè®¾ç½®ä¸­æ–­æ ‡å¿—ä½ä¸º trueï¼Œä½†ä¸ä¼šåœ¨è¿™ä¸ªwaitä¸ŠæŠ›å‡ºå¼‚å¸¸ï¼Œè€Œä¼šå½±å“åé¢çš„é˜»å¡æ“ä½œï¼Œå…·ä½“å¯ä»¥çœ‹ä¸‹é¢çš„Demo

  ```java
  public class NotifyInter {
      volatile int a = 0;
      public static void main(String[] args) {
          Object object = new Object();
          NotifyInter waitNotify = new NotifyInter();
          Thread thread1 = new Thread(new Runnable() {
              @Override
              public void run() {
                  synchronized (object) {
                      System.out.println("çº¿ç¨‹1 è·å–åˆ°ç›‘è§†å™¨é”");
                      try {
                          object.wait();
                          System.out.println("çº¿ç¨‹1 æ­£å¸¸æ¢å¤å•¦ã€‚ä½†æ˜¯ isInterrupt = "+ Thread.currentThread().isInterrupted());
                      } catch (InterruptedException e) {
                          System.out.println("çº¿ç¨‹1 waitæ–¹æ³•æŠ›å‡ºäº†InterruptedExceptionå¼‚å¸¸");
                      }
  
                      try {
                          TimeUnit.SECONDS.sleep(3);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                          System.out.println("åœ¨sleepä¸­è¢«ä¸­æ–­");
                      }
                  }
              }
          }, "çº¿ç¨‹1");
          thread1.start();
          // è¿™é‡Œè®© thread1 å’Œ thread2 å…ˆèµ·æ¥ï¼Œç„¶åå†èµ·åé¢çš„ thread3
         try {
              Thread.sleep(1000);
          } catch (InterruptedException e) {
          }
  
          new Thread(new Runnable() {
              @Override
              public void run() {
                  synchronized (object) {
                      System.out.println("çº¿ç¨‹3 æ‹¿åˆ°äº†ç›‘è§†å™¨é”ã€‚");
                      System.out.println("çº¿ç¨‹3 è®¾ç½®çº¿ç¨‹1ä¸­æ–­");
                      object.notify(); //2
                      waitNotify.a = 1; // è¿™è¡Œæ˜¯ä¸ºäº†ç¦æ­¢ä¸Šä¸‹çš„ä¸¤è¡Œä¸­æ–­å’Œnotifyä»£ç é‡æ’åº
                      thread1.interrupt(); // 1
                      System.out.println("çº¿ç¨‹3 è°ƒç”¨notify");
                      System.out.println("çº¿ç¨‹3 è°ƒç”¨å®Œnotifyåï¼Œä¼‘æ¯ä¸€ä¼š");
                      try {
                          Thread.sleep(1000);
                      } catch (InterruptedException e) {
                      }
                      System.out.println("çº¿ç¨‹3 ä¼‘æ¯å¤Ÿäº†ï¼Œç»“æŸåŒæ­¥ä»£ç å—");
                  }
              }
          }, "çº¿ç¨‹3").start();
      }
  }
  ```

### wait()å’Œsleep()çš„åŒºåˆ«

è¿™ä¹Ÿæ˜¯ä¸€é“é¢è¯•å¸¸é—®çš„é¢˜

â‘  é¦–å…ˆ`sleep()`æ˜¯çº¿ç¨‹Threadçš„é™æ€æ–¹æ³•ï¼Œ`wait()`æ˜¯`Object`ç±»çš„å®ä¾‹æ–¹æ³•

â‘¡`sleep()`ä¸ä¼šé‡Šæ”¾é”å¯¹è±¡ï¼Œ`wait()`ä¼šé‡Šæ”¾é”å¯¹è±¡ï¼Œè¿™ä¸€ç‚¹æ¯”è¾ƒé‡è¦

â‘¢ æ‰¿æ¥ç¬¬äºŒç‚¹ï¼Œ`wait()`ä¼šé‡Šæ”¾é”ï¼Œä½†æ˜¯è¦æ˜¯ä½ æ²¡æœ‰é”å‘¢ï¼Ÿå…¶å®å°±æ˜¯ä¸Šé¢è¯­æ³•å±‚é¢è¯´åˆ°çš„ï¼Œæ‰€ä»¥è°ƒç”¨`wait()`å¿…é¡»è¦`æŒæœ‰`é”å¯¹è±¡å¦åˆ™å°±ä¼šæŠ¥`IllegalMonitorStateException`

â‘£`sleep()`ä¸éœ€è¦è¢«å”¤é†’`timeout`åä¼šè‡ªåŠ¨é†’æ¥ï¼Œè€Œ`wait()`éœ€è¦è¢«å…¶ä»–çº¿ç¨‹å”¤é†’ï¼ˆ`wait(long time)`é™¤å¤–ï¼‰

### çº¿ç¨‹é€šè®¯ç»¼åˆæ¡ˆä¾‹

æ§åˆ¶åŒä¸€æ—¶é—´æ‰§è¡ŒåŒä¸€æ–¹æ³•çº¿ç¨‹çš„æ•°é‡

```java
public class ControlThreadNum {

    private static final LinkedList THREADS = new LinkedList<>();

    private final static int MAX_THREAD = 5;

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        List<Thread> worker = new ArrayList();
        //åˆ›å»ºäº†åä¸ªçº¿ç¨‹ï¼Œä½†æ˜¯æ§åˆ¶æ¯æ¬¡æœ€å¤šåŒæ—¶è¿è¡Œçš„åªæœ‰5ä¸ª
        Arrays.asList("M1", "M2", "M3", "M4", "M5", "M6", "M7", "M8", "M9", "M10").stream().map(ControlThreadNum::captureThread).forEach(t -> {
            t.start();
            worker.add(t);
        });
        //mainçº¿ç¨‹ç­‰å¾…workerçš„çº¿ç¨‹éƒ½æ‰§è¡Œå®Œ
        worker.stream().forEach(thread -> {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        Optional.of("All capture is done").ifPresent(System.out::println);
        Optional.of(System.currentTimeMillis() - start).ifPresent(System.out::println);
    }

    private static Thread captureThread(String name) {
        return new Thread(() -> {
            Optional.of("Thread " + Thread.currentThread().getName() + "  is begin").ifPresent(System.out::println);
            synchronized (THREADS) {
                while (THREADS.size() >= MAX_THREAD) {
                    try {
                        THREADS.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //THREADS åªæ˜¯ç”¨æ¥æ§åˆ¶æ•°é‡&é” å…ƒç´ æ˜¯ä»€ä¹ˆå¹¶ä¸é‡è¦
                THREADS.addLast(1);
            }
            //åˆ°è¿™é‡Œæ˜¯å¹¶è¡Œ
            Optional.of("Thread " + Thread.currentThread().getName() + "  is running").ifPresent(System.out::println);
            try {
                Thread.sleep(10000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            synchronized (THREADS) {
                Optional.of("Thread " + Thread.currentThread().getName() + "  is end").ifPresent(System.out::println);
                THREADS.removeLast();
                THREADS.notifyAll();
            }
        }, name);
    }
}
```

è¿™é‡Œä¸€å¼€å§‹ä¸€å…±åˆ›å»ºäº†10ä¸ªçº¿ç¨‹ï¼Œä½†æ˜¯æ‰§è¡Œçš„æ—¶å€™ä¼šæ§åˆ¶`running`çš„ä¸ªæ•°å°äº5ä¸ªï¼Œ`runnning`çº¿ç¨‹ä¸ªæ•°ç”¨ä¸€ä¸ª`LinkList`è®°å½•ï¼Œè‹¥`size()>=5`å°±è¿›å…¥`wait`ç„¶åå¦‚æœæœ‰çº¿ç¨‹`end`å°±ä¼š`notifyAll`å”¤é†’è¿›å…¥ç­‰å¾…çŠ¶æ€çš„çº¿ç¨‹ã€‚

```java
Thread M2  is begin
Thread M3  is begin
Thread M2  is running
Thread M1  is begin
Thread M1  is running
Thread M3  is running
Thread M4  is begin
Thread M4  is running
Thread M5  is begin
Thread M6  is begin
Thread M5  is running
Thread M7  is begin
Thread M8  is begin
Thread M9  is begin
Thread M10  is begin
Thread M3  is `end`
Thread M10  is running
Thread M5  is `end`
Thread M1  is `end`
Thread M2  is `end`
Thread M4  is `end`
Thread M6  is running
Thread M7  is running
Thread M9  is running
Thread M8  is running
Thread M10  is end
Thread M8  is end
Thread M9  is end
Thread M7  is end
Thread M6  is end
All capture is done
20124
```

è¿™æ ·å°±æ˜¯å…¶å®å°±æ˜¯ä¸ºäº†æé«˜æ•ˆç‡ï¼Œçº¿ç¨‹å¹¶ä¸æ˜¯è¶Šå¤šè¶Šå¥½ï¼Œçº¿ç¨‹åˆ›å»ºå¤ªå¤šï¼Œå°±ä¼šè¾¾åˆ°ç“¶é¢ˆï¼Œæ•ˆç‡åè€Œä¼šé™ä½ï¼Œå› ä¸ºæ—¶é—´éƒ½æ¶ˆè€—åœ¨äº†`çº¿ç¨‹åˆ‡æ¢`ä¸Šäº†ï¼Œå½“ç„¶è¿™æ˜¯åœ¨æ²¡æœ‰`çº¿ç¨‹æ± `çš„æƒ…å†µä¸‹ï¼Œåé¢ç”¨`çº¿ç¨‹æ± `å°±ä¸ä¼šè¿™ä¹ˆéº»çƒ¦äº†ã€‚

### wait()/notifyçš„å¼€é”€åŠé—®é¢˜

**è¿‡æ—©å”¤é†’** 

 æ¯”å¦‚ç”Ÿäº§è€…æ¶ˆè´¹è€…é—®é¢˜ä¸­ç”Ÿäº§è€…ç”Ÿäº§åå”¤é†’äº†ç”Ÿäº§è€…ï¼Œå…¶å®å°±æ˜¯è¿‡æ—©å”¤é†’äº†ï¼Œè¿‡æ—©å”¤é†’ä½¿å¾—é‚£äº›æœ¬æ¥æ— é¡»è¢«å”¤é†’çš„ç­‰å¾…çº¿ç¨‹ä¹Ÿè¢«å”¤é†’äº†ï¼Œä»è€Œé€ æˆèµ„æºæµªè´¹ã€‚è¿™å°±å¥½æ¯”ä½ åœ¨äººç¾¤é‡Œå¤§å–Šä¸€å£°â€œç¾å¥³â€ï¼Œä¾¿ä¼šæœ‰è®¸å¤šè‡ªæˆ‘æ„Ÿè§‰è‰¯å¥½çš„å¥³æ€§å›å¤´ä¸€æ ·â€”â€”å°½ç®¡ä½ è¦å–Šçš„ä»…ä»…æ˜¯å…¶ä¸­æŸä¸€ä¸ªäººï¼Œä½†å¤§å®¶å´éƒ½ä»¥ä¸ºä½ æ˜¯åœ¨å–Šè‡ªå·±ã€‚è¿‡æ—©å”¤é†’é—®é¢˜å¯ä»¥åˆ©ç”¨JDK
1.5å¼•å…¥çš„`java.util.concurrent.locks.Condition`æ¥å£æ¥è§£å†³ï¼Œåé¢çš„æ–‡ç« ä¼šè®²åˆ°ã€‚

**ä¿¡å·ä¸¢å¤±**

ä¿¡å·ä¸¢å¤±ï¼ˆMissed Signalï¼‰é—®é¢˜ã€‚å¦‚æœç­‰å¾…çº¿ç¨‹åœ¨æ‰§è¡Œ`Object.wait()`å‰æ²¡æœ‰å…ˆåˆ¤æ–­ä¿æŠ¤æ¡ä»¶æ˜¯å¦å·²ç„¶æˆç«‹ï¼Œé‚£ä¹ˆæœ‰å¯èƒ½å‡ºç°è¿™ç§æƒ…å½¢â€”â€”é€šçŸ¥çº¿ç¨‹åœ¨è¯¥ç­‰å¾…çº¿ç¨‹è¿›äººä¸´ç•ŒåŒºä¹‹å‰å°±å·²ç»æ›´æ–°äº†ç›¸å…³å…±äº«å˜é‡ï¼Œä½¿å¾—ç›¸åº”çš„ä¿æŠ¤æ¡ä»¶æˆç«‹å¹¶è¿›è¡Œäº†é€šçŸ¥ï¼Œä½†æ˜¯æ­¤æ—¶ç­‰å¾…çº¿ç¨‹è¿˜æ²¡æœ‰è¢«æš‚åœï¼Œè‡ªç„¶ä¹Ÿå°±æ— æ‰€è°“å”¤é†’äº†ã€‚è¿™å°±å¯èƒ½é€ æˆç­‰å¾…çº¿ç¨‹ç›´æ¥æ‰§è¡Œ`Object.wait()`è€Œè¢«æš‚åœçš„æ—¶å€™ï¼Œè¯¥çº¿ç¨‹ç”±äºæ²¡æœ‰å…¶ä»–çº¿ç¨‹è¿›è¡Œé€šçŸ¥è€Œä¸€ç›´å¤„äºç­‰å¾…çŠ¶æ€ã€‚è¿™ç§ç°è±¡å°±ç›¸å½“äºç­‰å¾…çº¿ç¨‹é”™è¿‡äº†ä¸€ä¸ªæœ¬æ¥â€œå‘é€â€ç»™å®ƒçš„â€œä¿¡å·â€ï¼Œå› æ­¤è¢«ç§°ä¸ºä¿¡å·ä¸¢å¤±ï¼ˆMissed Signalï¼‰ã€‚åªè¦å°†å¯¹ä¿æŠ¤æ¡ä»¶çš„åˆ¤æ–­å’Œ`Object.wait()`è°ƒç”¨æ”¾åœ¨ä¸€ä¸ªå¾ªç¯è¯­å¥ä¹‹ä¸­å°±å¯ä»¥é¿å…ä¸Šè¿°åœºæ™¯çš„ä¿¡å·ä¸¢å¤±ã€‚ä¿¡å·ä¸¢å¤±çš„å¦å¤–ä¸€ä¸ªè¡¨ç°æ˜¯åœ¨åº”è¯¥è°ƒç”¨`Object.notifyAll()` çš„åœ°æ–¹å´è°ƒç”¨äº†`Object.notify()`ã€‚æ¯”å¦‚ï¼Œå¯¹äºä½¿ç”¨åŒä¸€ä¸ªä¿æŠ¤æ¡ä»¶çš„å¤šä¸ªç­‰å¾…çº¿ç¨‹ï¼Œå¦‚æœé€šçŸ¥çº¿ç¨‹åœ¨ä¾¦æµ‹åˆ°è¿™ä¸ªä¿æŠ¤æ¡ä»¶æˆç«‹åè°ƒç”¨çš„æ˜¯`Object.notify()`ï¼Œé‚£ä¹ˆè¿™äº›ç­‰å¾…çº¿ç¨‹æœ€å¤šåªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½å¤Ÿè¢«å”¤é†’ï¼Œç”šè‡³ä¸€ä¸ªä¹Ÿæ²¡æœ‰è¢«å”¤é†’â€”â€”è¢«å”¤é†’çš„çº¿ç¨‹æ˜¯`Object.notify()`æ‰€å±å¯¹è±¡ä¸Šä½¿ç”¨å…¶ä»–ä¿æŠ¤æ¡ä»¶çš„ä¸€ä¸ªç­‰å¾…çº¿ç¨‹ï¼ä¹Ÿå°±æ˜¯è¯´ï¼Œå°½ç®¡é€šçŸ¥çº¿ç¨‹åœ¨è°ƒç”¨`Object.notify()`å‰å¯èƒ½è€ƒè™‘ï¼ˆåˆ¤æ–­ï¼‰äº†æŸä¸ªç‰¹å®šçš„ä¿æŠ¤æ¡ä»¶æ˜¯å¦æˆç«‹ï¼Œä½†æ˜¯`Object.notify()`æœ¬èº«åœ¨å…¶å”¤é†’çº¿ç¨‹æ—¶æ˜¯ä¸è€ƒè™‘ä»»ä½•ä¿æŠ¤æ¡ä»¶çš„ï¼è¿™å°±å¯èƒ½ä½¿å¾—é€šçŸ¥çº¿ç¨‹æ‰§è¡Œ`Object.notify()`è¿›è¡Œçš„é€šçŸ¥å¯¹äºä½¿ç”¨ç›¸åº”ä¿æŠ¤æ¡ä»¶çš„ç­‰å¾…çº¿ç¨‹æ¥è¯´ä¸¢å¤±äº†ã€‚è¿™ç§æƒ…å½¢ä¸‹ï¼Œé¿å…ä¿¡å·ä¸¢å¤±çš„ä¸€ä¸ªæ–¹æ³•æ˜¯åœ¨å¿…è¦çš„æ—¶å€™ä½¿ç”¨`Object.notifyAll()`æ¥é€šçŸ¥ã€‚æ€»çš„æ¥è¯´ï¼Œä¿¡å·ä¸¢å¤±æœ¬è´¨ä¸Šæ˜¯ä¸€ç§ä»£ç é”™è¯¯ï¼Œè€Œä¸æ˜¯Javaæ ‡å‡†åº“APIè‡ªèº«çš„é—®é¢˜ã€‚

**æ¬ºéª—æ€§å”¤é†’**

ç”±äºè«åå…¶å¦™çš„åŸå› ï¼Œçº¿ç¨‹æœ‰å¯èƒ½åœ¨æ²¡æœ‰è°ƒç”¨è¿‡`notify()`å’Œ`notifyAll()`çš„æƒ…å†µä¸‹é†’æ¥ã€‚è¿™å°±æ˜¯æ‰€è°“çš„å‡å”¤é†’ï¼ˆspurious wakeupsï¼‰ï¼Œæ— ç«¯ç«¯åœ°é†’è¿‡æ¥äº†ï¼Œç„¶è€Œæ­¤æ—¶å¯èƒ½ä¿æŠ¤æ¡ä»¶å¹¶æ²¡æœ‰æˆç«‹ã€‚è¿™ä¸ªé—®é¢˜çš„è§£å†³åŒæ ·æ˜¯è®² ä¿æŠ¤æ¡ä»¶å’Œwaitæ”¾åœ¨ä¸´ç•ŒåŒºå†…åŒä¸€ä¸ªå¾ªç¯ä½“å†…å°±å¯ä»¥äº†ã€‚

**ä¸Šä¸‹æ–‡åˆ‡æ¢**

â€‹	é¦–å…ˆï¼Œç­‰å¾…çº¿ç¨‹æ‰§è¡Œ`Object.wait()`è‡³å°‘ä¼šå¯¼è‡´è¯¥çº¿ç¨‹å¯¹ç›¸åº”å¯¹è±¡å†…éƒ¨é”çš„ä¸¤æ¬¡ç”³è¯·ä¸é‡Šæ”¾ã€‚é€šçŸ¥çº¿ç¨‹åœ¨æ‰§è¡Œ`Object.notify()/notifyAll()`æ—¶éœ€è¦æŒæœ‰ç›¸åº”å¯¹è±¡çš„å†…éƒ¨é”ï¼Œå› æ­¤`Object.notify()/notifyAll()`è°ƒç”¨ä¼šå¯¼è‡´ä¸€æ¬¡é”çš„ç”³è¯·ã€‚è€Œé”çš„ç”³è¯·ä¸é‡Šæ”¾å¯èƒ½å¯¼è‡´ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚

â€‹	å…¶æ¬¡ï¼Œç­‰å¾…çº¿ç¨‹ä»è¢«æš‚åœåˆ°å”¤é†’è¿™ä¸ªè¿‡ç¨‹æœ¬èº«å°±ä¼šå¯¼è‡´ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚

â€‹	å†æ¬¡ï¼Œè¢«å”¤é†’çš„ç­‰å¾…çº¿ç¨‹åœ¨ç»§ç»­è¿è¡Œæ—¶éœ€è¦å†æ¬¡ç”³è¯·ç›¸åº”å¯¹è±¡çš„å†…éƒ¨é”ï¼Œæ­¤æ—¶ç­‰å¾…çº¿ç¨‹å¯èƒ½éœ€è¦å’Œç›¸åº”å¯¹è±¡çš„å…¥å£é›†ä¸­çš„å…¶ä»–çº¿ç¨‹ä»¥åŠå…¶ä»–æ–°æ¥çš„æ´»è·ƒçº¿ç¨‹ï¼ˆå³ç”³è¯·ç›¸åº”çš„å†…éƒ¨é”ä¸”å¤„äºRUNNABLEçŠ¶æ€çš„çº¿ç¨‹ï¼‰äº‰ç”¨ç›¸åº”çš„å†…éƒ¨é”ï¼Œè€Œè¿™åˆå¯èƒ½å¯¼è‡´ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚
æœ€åï¼Œè¿‡æ—©å”¤é†’é—®é¢˜ä¹Ÿä¼šå¯¼è‡´é¢å¤–çš„ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œè¿™æ˜¯å› ä¸ºè¢«è¿‡æ—©å”¤é†’çš„çº¿ç¨‹ä»ç„¶éœ€è¦ç»§ç»­ç­‰å¾…ï¼Œå³å†æ¬¡ç»å†è¢«æš‚åœå’Œå”¤é†’çš„è¿‡ç¨‹ã€‚

[æ›´å¤šå‚è€ƒ](http://ifeve.com/thread-signaling/)

## 13.æ‰‹å†™ä¸€ä¸ªBooleanLock

`Synchronized`çš„ç¼ºç‚¹å…¶å®å¾ˆæ˜æ˜¾ï¼Œå½“å¤šä¸ªçº¿ç¨‹ç«äº‰é”çš„æ—¶å€™ï¼Œå½“ä¸€ä¸ªçº¿ç¨‹æŠ¢åˆ°é”åå…¶ä»–çš„çº¿ç¨‹åªèƒ½å‚»å‚»çš„ç­‰ç€ï¼Œè¿™æ ·ä¼šå½±å“æ•ˆç‡ï¼Œæ‰€ä»¥è¿™é‡Œå¯ä»¥è‡ªå·±ç®€å•æ‰‹å†™ä¸€ä¸ªé™åˆ¶ç­‰å¾…æ—¶é—´çš„é”ã€‚

### LOCKæ¥å£

```java
public interface Lock {

    class TimeOutException extends Exception {
        public TimeOutException(String message) {
            super(message);
        }
    }

    void lock() throws InterruptedException;

    void lock(long time) throws InterruptedException,TimeOutException;

    void unLock() throws InterruptedException;

    Collection<Thread> getBlockThread();
}
```

å®šä¹‰äº†ä¸€ä¸ª`TimeOutException`

### BooleanLockå®ç°ç±»

```java
public class BooleanLock implements Lock {

    //false indicated free
    private boolean initValue;
    //åŠ é”çš„çº¿ç¨‹
    private Thread lockedThread;

    private Collection<Thread> blockThreadCollection = new ArrayList<>();

    public BooleanLock() {
        this.initValue = false;
    }

    @Override
    public synchronized void lock() throws InterruptedException {
        while (initValue) {
            blockThreadCollection.add(Thread.currentThread());
            System.out.println(Thread.currentThread().getName() + " is wait");
            this.wait();
        }
        blockThreadCollection.remove(Thread.currentThread());
        this.initValue = true;
        this.lockedThread = Thread.currentThread();
    }

    @Override
    public synchronized void lock(long time) throws InterruptedException, TimeOutException {
        if (time <= 0) lock();
        long remainTime=time;
        long endTime=System.currentTimeMillis()+time;
        while (initValue){
            if(remainTime<=0){
                throw new TimeOutException("time is out");
            }
            blockThreadCollection.add(Thread.currentThread());
            this.wait(time);
            remainTime=endTime-System.currentTimeMillis();
        }
        this.initValue=true;
        this.lockedThread=Thread.currentThread();
        blockThreadCollection.remove(Thread.currentThread());
    }

    @Override
    public synchronized void unLock() {
        //åˆ¤æ–­æ˜¯ä¸æ˜¯åŠ é”çš„çº¿ç¨‹
        if (lockedThread == Thread.currentThread()) {
            this.initValue = false;
            this.notifyAll();
            Optional.of(Thread.currentThread().getName() + "  release the lock monitor").ifPresent(System.out::println);
        }
    }

    @Override
    public Collection<Thread> getBlockThread() {
        return Collections.unmodifiableCollection(blockThreadCollection);
    }
}
```

### æµ‹è¯•BooleanLockçš„æ•ˆæœ

```java
public class LockTest {
    public static void main(String[] args) {
        final BooleanLock booleanLock = new BooleanLock();
        Stream.of("t0", "t1", "t2").forEach(name -> {
            new Thread(() -> {
                try {
                    booleanLock.lock(10);
                    Optional.of(Thread.currentThread().getName() + " get the lock").ifPresent(System.out::println);
                    doSomething();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (Lock.TimeOutException e) {
                    System.out.println(Thread.currentThread().getName()+" Time out");
                    e.printStackTrace();
                } finally {
                    booleanLock.unLock();
                }
            }, name).start();
        });
        //mainçº¿ç¨‹é‡Šæ”¾é”ï¼Œä¸åº”è¯¥ï¼Œè°åŠ çš„é”åº”è¯¥ç”±è°å»é‡Šæ”¾é”
        //booleanLock.unLock();
    }

    private static void doSomething() {
        Optional.of(Thread.currentThread().getName() + " is working...").ifPresent(System.out::println);
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

è¿™é‡Œè®¾ç½®åœ¨æŠ¢ä¸åˆ°é”çš„æ—¶å€™ï¼Œåªç­‰å¾…`10ms`ï¼Œç„¶å`doSomething`ä¼š`sleep`5000msï¼Œæ‰€ä»¥åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥æŠ¢åˆ°é”åé¢çš„éƒ½ä¼šè¶…æ—¶ throw `TimeOutException`å…¸å‹çš„`é™æ—¶ç­‰å¾…`æ¨¡å‹

```java
t0 get the lock
t0 is working...
`base_thread_study.chaper10.Lock$TimeOutException: time is out`
	at base_thread_study.chaper10.BooleanLock.lock(BooleanLock.java:41)
	at base_thread_study.chaper10.LockTest.lambda$null$0(LockTest.java:12)
	at java.lang.Thread.run(Thread.java:748)
`base_thread_study.chaper10.Lock$TimeOutException: time is out`
	at base_thread_study.chaper10.BooleanLock.lock(BooleanLock.java:41)
	at base_thread_study.chaper10.LockTest.lambda$null$0(LockTest.java:12)
	at java.lang.Thread.run(Thread.java:748)
t2 Time out
t1 Time out
t0  release the lock monitor
```

## 14.ç»™åº”ç”¨ç¨‹åºæ³¨å…¥é’©å­Hook

å…³äº`Hook`æ˜¯ä»€ä¹ˆå°±ä¸å¤šä»‹ç»äº†ï¼Œè¿™é‡Œçš„é’©å­å’Œ`git`,`svn`é‡Œé¢çš„æ˜¯ä¸€æ ·çš„ï¼Œç±»ä¼¼çš„åœ¨ä½¿ç”¨`Tomcat`ç­‰æœåŠ¡çš„æ—¶å€™ï¼Œåœ¨ä½ å…³é—­å®ƒä¹‹åå®ƒä»ç„¶ä¼šæ‰“å°æ—¥å¿—å’Œé‡Šæ”¾ä¸€äº›èµ„æºï¼Œè¿™å°±æ˜¯`Hook`çš„ä¸€ç§ï¼Œå½“ç„¶`Hook`æœ‰å¤šç§ï¼Œè¿™åªæ˜¯å…¶ä¸­ä¸€ç§ã€‚

```java
public class ExitCap{
	public static void main(String []arg){
	int i=0;
	Runtime.getRuntime().addShutdownHook(new Thread(()->{
   	    System.out.println("The test app will shutdown");
	    notifyAndRelease();
	}));
	while(true){
		try{
		Thread.sleep(1000);
		System.out.println("i am working");
		}catch(Exception e){
		 //donothing
		}
		if(i>10){
		   throw new RuntimeException();
		}
		i++;    
	}
    }

    public static void notifyAndRelease(){
	System.out.println("notify to admin");
    	
	try{
	Thread.sleep(1000);
	}catch(Exception e){}
	
	System.out.println("release the resources(socker. file, connection.)");
	
	try{
        Thread.sleep(1000);
        }catch(Exception e){}
	
	System.out.println("release and notify done");
    }
}

```

è¿™é‡Œæ˜¯åœ¨`Linux`ä¸Šè¿›è¡Œçš„æµ‹è¯•ï¼Œå› ä¸ºæ•ˆæœæ¯”è¾ƒæ˜æ˜¾ï¼Œé¡ºä¾¿ä¹Ÿç†Ÿæ‚‰ä¸‹`Linux`çš„å‘½ä»¤ï¼Œå¯ä»¥çœ‹åˆ°ä¸Šé¢çš„é’©å­å°±æ˜¯é€šè¿‡`Runtime.getRuntime().addShutdownHook()`æ³¨å…¥äº†ä¸€ä¸ª`Thread`è¿›å»çš„ï¼Œè¿™æ ·å°±ä¼šæ£€æµ‹åˆ°ç¨‹åºçš„é€€å‡ºå¹¶è§¦å‘`Hook`åšä¸€äº›é‡Šæ”¾èµ„æºä¹‹ç±»çš„å·¥ä½œã€‚

```java
i am working
i am working
i am working
i am working
i am working
i am working
i am working
i am working
i am working
i am working
i am working
Exception in thread "main" java.lang.RuntimeException
	at base_thread_study.chaper10.ExitCap.main(ExitCap.java:18)
i am working
`The test app will shutdown`
`notify to admin`
`release the resources(socker. file, connection.)`
`release and notify done`
```

ä¸Šé¢æ˜¯åœ¨æ­£å¸¸æƒ…å†µä¸‹ç»ˆæ­¢çº¿ç¨‹æ¯”å¦‚ `å¼‚å¸¸`ï¼Œ`ctrl C`æˆ–è€… `kill pid`å¦‚æœä½¿ç”¨ `kill -9 pid`å°±ä¸ä¼šè§¦å‘é’©å­ï¼Œå¼ºåˆ¶åœæ­¢ï¼Œæ‰€ä»¥ä¸€èˆ¬ä¸å»ºè®®ç”¨`kill -9`

## 15.æ•è·çº¿ç¨‹çš„Runtimeå¼‚å¸¸

åœ¨Javaå¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œæ‰€æœ‰çº¿ç¨‹éƒ½ä¸å…è®¸æŠ›å‡ºæœªæ•è·çš„`checked exception`(æ¯”å¦‚sleepçš„InterruptException)ï¼Œä¹Ÿå°±æ˜¯å„ä¸ªçº¿ç¨‹å¿…é¡»è‡ªå·±æŠŠè‡ªå·±çš„`checked exception`å¤„ç†æ‰ï¼Œä½†æ˜¯å¦‚æœæ˜¯`unchecked exception `å‘¢ï¼Ÿä¸»è¦å°±æ˜¯æŒ‡`RuntimeException`æ­¤ç±»å¼‚å¸¸æŠ›å‡ºæ—¶è¯¥çº¿ç¨‹ä¼š`shutdown`ä½†æ˜¯å…¶å®ƒçº¿ç¨‹ä¸å—å½±å“ä¹Ÿæ— æ³•æ„ŸçŸ¥åˆ°è¿™ä¸ªå¼‚å¸¸ï¼Œå°±åƒä¸‹é¢çš„ä¾‹å­

```java
public class ThreadException {
    public static void main(String[] args) {
        Thread thread = null;
        try {
            thread=new Thread(()->{
                int res=1/0;
            });
            thread.start();
        }catch (Exception e){
            System.out.println("æ•è·åˆ°å¼‚å¸¸");
        }
    }
}
```

æ§åˆ¶å°è¾“å‡º`mainçº¿ç¨‹`å¹¶æ²¡æœ‰æ•è·åˆ°å¼‚å¸¸ï¼Œå…¶å®è¿™ä¹Ÿæ˜¯ä¸€ç§å¾ˆå¥½çš„ç†å¿µï¼Œæ¯ä¸ªçº¿ç¨‹çš„äº‹æƒ…åº”è¯¥ç”±çº¿ç¨‹è‡ªå·±å»å¤„ç†ä¸åº”è¯¥ç”±å…¶ä»–çº¿ç¨‹å»å¹²æ‰°ï¼Œæ­£å¦‚`stop/resume/suspend`è¿™äº›æ–¹æ³•è¢«å¼ƒç”¨çš„åŸå› ã€‚ä½†æ˜¯è¿™äº›å¼‚å¸¸å¦‚æœä¸å»å¤„ç†å¯èƒ½ä¼šå¯¼è‡´ä¸€äº›ä¸¥é‡çš„åæœï¼ŒJDK1.5ä¹‹åå®˜æ–¹ä¹Ÿæä¾›äº†APIå»å¤„ç†çº¿ç¨‹çš„å¼‚å¸¸ã€‚setDefaultUncaughtExceptionHandler()å’ŒsetUncaughtExceptionHandler()å‰è€…æ˜¯`Thread`çš„é™æ€æ–¹æ³•ï¼Œç”¨äºç»™æ‰€æœ‰çš„çº¿ç¨‹è®¾ç½®é»˜è®¤çš„å¼‚å¸¸å¤„ç†ï¼Œåè€…æ˜¯å®ä¾‹æ–¹æ³•ï¼Œé’ˆå¯¹æ¯ä¸ªçº¿ç¨‹ä¼šç»™æ¯ä¸ªçº¿ç¨‹åŠ ä¸Šä¸€ä¸ªå¼‚å¸¸å¤„ç†å™¨ï¼Œå¦‚ä¸‹Demo

```java
public class ThreadException {
    private static int A = 10;
    private static int B = 0;

    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
              int res = A / B;
            }
        );
        //æœ€å¥½åœ¨startå‰è®¾ç½®å¼‚å¸¸å¤„ç†å™¨ï¼Œæ”¾åœ¨åé¢å¯èƒ½ä¼šèµ·ä¸åˆ°ä½œç”¨ã€‚
        thread.setUncaughtExceptionHandler((t, e) -> {
            System.out.println(t.getName());
            System.out.println(e);
        });
        thread.start();
    }
}
```

> `Thread-0`
> `java.lang.ArithmeticException: / by zero`

å¯ä»¥çœ‹åˆ°å·²ç»æ•è·åˆ°äº†è¿™ä¸ªå¼‚å¸¸ï¼Œå½“çº¿ç¨‹é‡åˆ°æœªæ•è·çš„å¼‚å¸¸è€Œç»“æŸæ—¶ä¼šè°ƒç”¨`UncaughtExceptionHandler` å¤„ç†ä¸€äº›"åäº‹"å’Œé‡Šæ”¾ä¸€äº›å®è´µçš„èµ„æºï¼Œ`setUncaughtExceptionHandler`å»ºè®®æ”¾åœ¨çº¿ç¨‹startä¹‹å‰ï¼Œä¸ç„¶å¯èƒ½èµ·ä¸åˆ°ä½œç”¨ã€‚

## 16.ThreadGroupçº¿ç¨‹ç»„

### è·å–çº¿ç¨‹ç»„ä¿¡æ¯

```java
public class ThreadGroupAPI {
    public static void main(String[] args) {
        ThreadGroup tgp = new ThreadGroup("TGP1");
        Thread t = new Thread(tgp, "t0") {
            @Override
            public void run() {
                while (true) {
                    try {
                        System.out.println(getThreadGroup().getName());
                        System.out.println(getThreadGroup().getParent());
                        //å¯ä»¥è®¿é—®ï¼Œæ–‡æ¡£ä¸Šè¯´ä¸è¡Œ
                        System.out.println(getThreadGroup().getParent().activeCount());
                        Thread.sleep(10000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        t.start();

        ThreadGroup tgp2 = new ThreadGroup("TGP2");
        Thread t1 = new Thread(tgp2, "t0") {
            @Override
            public void run() {
                System.out.println(tgp.getName());
                System.out.println(tgp.activeCount());
                Thread[] threads=new Thread[tgp.activeCount()];
                tgp.enumerate(threads);
                //ä¹Ÿå¯ä»¥è®¿é—®
                Arrays.asList(threads).forEach(System.out::println);
            }
        };
        t1.start();
        //System.out.println(tgp2.getName());
        //System.out.println(tgp2.getParent().getName());
    }
}
```

æ–‡æ¡£ä¸Šè¯´çš„ä¸èƒ½è®¿é—®å…¶ä»–çº¿ç¨‹ç»„çš„ä¿¡æ¯ï¼Œè¿™é‡Œæµ‹è¯•çš„å‡ ä¸ªéƒ½å¯ä»¥ï¼Œå¯èƒ½æè¿°æœ‰ç‚¹é—®é¢˜ï¼Œ`çº¿ç¨‹ç»„`çš„åˆ›å»ºç±»ä¼¼äº`çº¿ç¨‹`çš„åˆ›å»ºï¼Œå¦‚æœæ²¡æœ‰æ˜¾ç¤ºçš„æŒ‡å®šçº¿ç¨‹ç»„éƒ½ä¼šé»˜è®¤åŠ åˆ°çˆ¶çº¿ç¨‹çš„çº¿ç¨‹ç»„ä¸­ã€‚

### æ‰“æ–­çº¿ç¨‹ç»„interrupt()

> Interrupts all threads in this thread group.
>
> First, the <code>checkAccess</code> method of this thread group is
>
> called with no arguments; this may result in a security exception.
>
> This method then calls the <code>interrupt</code> method on all the
>
> threads in this thread group and in `all of its subgroups.`

æ‰“æ–­è¯¥çº¿ç¨‹ç»„é‡Œé¢æ‰€æœ‰çš„çº¿ç¨‹ï¼ŒåŒ…æ‹¬å­çº¿ç¨‹ç»„çš„çº¿ç¨‹ã€‚

### çº¿ç¨‹ç»„setDaemon()

å’Œçº¿ç¨‹çš„`setDaemon`ä¸ä¸€æ ·ã€‚

> Changes the daemon status of this thread group.
>
> First, the <code>checkAccess</code> method of this thread group is
>
> called with no arguments; this may result in a security exception.
>
> A daemon thread group is `automatically` `destroyed` when its last
>
> thread is stopped or its `last thread group is destroyed`.

å½“æœ€åä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œå®Œæ¯•åè‡ªåŠ¨é”€æ¯çº¿ç¨‹ç»„ï¼Œå½“ç„¶ä¸å…¶å¯¹åº”çš„ä¹Ÿæœ‰æ‰‹åŠ¨é”€æ¯çš„æ–¹æ³•`destroy()`è¿™ä¸ªæ–¹æ³•å¦‚æœçº¿ç¨‹æ²¡æ‰§è¡Œå®Œæ¯•å°±è°ƒç”¨ä¼šæŠ›`IllegalThreadStateException`ï¼Œå…¶ä»–çš„æ–¹æ³•è¯¦ç»†å¯ä»¥å‚è€ƒæ–‡æ¡£ã€‚

## 17.çº¿ç¨‹æ± 

### ä¸ºä»€ä¹ˆè¦ä½¿ç”¨çº¿ç¨‹æ± 

 åˆ›å»ºå’Œé”€æ¯çº¿ç¨‹å¼€é”€å¤§ï¼Œåˆ©ç”¨å¥½çº¿ç¨‹æ± å¯ä»¥é¿å…cpuèŠ±è´¹ä¸å¿…è¦çš„æ—¶é—´åœ¨è¿™ä¸Šé¢ï¼Œä»è€Œä¸“æ³¨äºå…·ä½“çš„ä»»åŠ¡:)

åŸºæœ¬çš„çº¿ç¨‹æ± åŒ…æ‹¬ä¸‹é¢å‡ éƒ¨åˆ†ï¼š

â‘ ä»»åŠ¡é˜Ÿåˆ—

â‘¡æ‹’ç»ç­–ç•¥(æŠ›å‡ºå¼‚å¸¸ï¼Œç›´æ¥ä¸¢å¼ƒï¼Œé˜»å¡ï¼Œä¸´æ—¶é˜Ÿåˆ—)

â‘¢`init`(`min`)åˆå§‹å¤§å°

â‘£`active`ä¸­é—´å¸¸æ€å¤§å°

â‘¤`max`æœ€å¤§ä¸ªæ•°ï¼Œè¶…è¿‡å°±ä¼šåŠ åˆ°ä»»åŠ¡é˜Ÿåˆ—ä¸­ï¼Œä»»åŠ¡é˜Ÿåˆ—ä¹Ÿæ»¡å°±ä¼šæ‰§è¡Œæ‹’ç»ç­–ç•¥

> min<=active<=max

### æ‰‹å†™çº¿ç¨‹æ± 

#### ä¸´æ—¶é˜Ÿåˆ—

```java
public class SimpleThreadPool {
    //çº¿ç¨‹æ± å¤§å°
    private final int size;
    //é»˜è®¤å¤§å°
    private final static int DEFAULT_SIZE = 10;
	//ä»»åŠ¡é˜Ÿåˆ—
    private final static LinkedList<Runnable> TASK_QUEUE = new LinkedList<>();
	//çº¿ç¨‹åºå·
    private static volatile int seq = 0;
	//çº¿ç¨‹ç»„
    private final static ThreadGroup GROUP = new ThreadGroup("Pool_Group");
	//çº¿ç¨‹å‰ç¼€å
    private final static String THREAD_PREFIX = "SIMPLE_THREAD_POOL-";
	//çº¿ç¨‹é˜Ÿåˆ—
    private final static List<MyThread> THREAD_QUEUE = new ArrayList<>();

    public SimpleThreadPool(int size) {
        this.size = size;
        init();
    }

    public SimpleThreadPool() {
        this(DEFAULT_SIZE);
    }

    private void init() {
        for (int i = 0; i < size; i++) {
            createThreadQueue();
        }
    }
	
    //æš´éœ²å¯¹å¤–çš„æ¥å£ï¼Œæäº¤ä»»åŠ¡é˜Ÿåˆ—
    public void submit(Runnable runnable) {
        synchronized (TASK_QUEUE) {
            TASK_QUEUE.addLast(runnable);
            //å”¤é†’çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹
            TASK_QUEUE.notifyAll();
        }
    }

    private void createThreadQueue() {
        MyThread thread = new MyThread(GROUP, THREAD_PREFIX + (seq++));
        thread.start();
        THREAD_QUEUE.add(thread);
    }

    private enum ThreadState {
        FREE, RUNNING, BLOCKED, DEAD
    }
	
    //åŒ…è£…çš„çº¿ç¨‹ç±»
    private static class MyThread extends Thread {
        private volatile ThreadState threadState = ThreadState.FREE;

        public ThreadState getThreadState() {
            return this.threadState;
        }

        public MyThread(ThreadGroup group, String name) {
            super(group, name);
        }

        @Override
        public void run() {
            OUTER:
            while (this.threadState != ThreadState.DEAD) {
                //å½“å‰çº¿ç¨‹æ²¡æœ‰dead
                Runnable runnable;
                synchronized (TASK_QUEUE) {
                    while (TASK_QUEUE.isEmpty()) {
                        //ä»»åŠ¡é˜Ÿåˆ—ä¸ºç©ºï¼Œå…¨å‘˜wait
                        try {
                            this.threadState = ThreadState.BLOCKED;
                            TASK_QUEUE.wait();
                        } catch (InterruptedException e) {
                            System.out.println("break");
                            break OUTER;
                        }
                    }
                    runnable = TASK_QUEUE.removeFirst();
                }
                //è¿™é‡Œåº”è¯¥å¹¶è¡Œ
                Optional.of(runnable).ifPresent(t -> {
                    this.threadState = ThreadState.RUNNING;
                    t.run();
                    this.threadState = ThreadState.FREE;
                });
            }
        }

        public void close() {
            this.threadState = ThreadState.DEAD;
        }
    }
}
```

æœ€å¼€å§‹å®ç°çš„æ—¶å€™`synchronized`çš„èŒƒå›´å¤ªå¤§ï¼Œå°†å…·ä½“çš„æ‰§è¡Œ`run`çš„è¿‡ç¨‹ä¹ŸåŒæ­¥äº†èµ·æ¥ï¼Œè¿™æ˜æ˜¾æ˜¯æœ‰é—®é¢˜çš„ï¼Œåªéœ€è¦åŒæ­¥å…±äº«å˜é‡å°±å¯ä»¥äº†ï¼ŒåŒæ­¥äº†åé¢çš„ä»£ç é‚£å°±è·Ÿå•çº¿ç¨‹ä¸€æ ·äº†ã€‚

#### å…³é—­çº¿ç¨‹æ± &æ‹’ç»ç­–ç•¥

```java
public class SimpleThreadPool {
    //çº¿ç¨‹æ± å¤§å°
    private final int size;
	//ä»»åŠ¡é˜Ÿåˆ—å¤§å°
    private final int queueSize;
	//é»˜è®¤çº¿ç¨‹æ± å¤§å°
    private final static int DEFAULT_SIZE = 10;
	//çº¿ç¨‹æ± ä¸­çº¿ç¨‹ç¼–å·
    private static volatile int seq = 0;
	//é»˜è®¤ä»»åŠ¡é˜Ÿåˆ—çš„å¤§å°
    private final static int DEFAULT_TASK_QUEUE_SIZE = 2000;
	//çº¿ç¨‹ç»„
    private final static ThreadGroup GROUP = new ThreadGroup("Pool_Group");
	//çº¿ç¨‹åå‰ç¼€
    private final static String THREAD_PREFIX = "SIMPLE_THREAD_POOL-";
	//ä»»åŠ¡é˜Ÿåˆ—
    private final static LinkedList<Runnable> TASK_QUEUE = new LinkedList<>();
	//çº¿ç¨‹é˜Ÿåˆ—
    private final static List<MyThread> THREAD_QUEUE = new ArrayList<>();
	//æ‹’ç»ç­–ç•¥
    private final DiscardPolicy discardPolicy;
	//çº¿ç¨‹æ¬¡æ˜¯å¦é”€æ¯
    private volatile boolean destroy = false;
	//é»˜è®¤çš„æ‹’ç»ç­–ç•¥ï¼ˆæŠ›å¼‚å¸¸ï¼‰
    public final static DiscardPolicy DEFAULT_DISCARD_POLICY = () -> {
        throw new DiscardException("Discard this Task!!!!(Default Policy)");
    };
    public SimpleThreadPool(int size, int queueSize, DiscardPolicy discardPolicy) {
        this.size = size;
        this.queueSize = queueSize;
        this.discardPolicy = discardPolicy;
        init();
    }

    public SimpleThreadPool() {
        this(DEFAULT_SIZE, DEFAULT_TASK_QUEUE_SIZE, DEFAULT_DISCARD_POLICY);
    }

    private void init() {
        for (int i = 0; i < size; i++) {
            createThreadQueue();
        }
    }

    public void submit(Runnable runnable) {
        if (destroy) {
            throw new IllegalStateException("The Pool is shutdown , you can't submit now ! !");
        }
        synchronized (TASK_QUEUE) {
            if (TASK_QUEUE.size() > queueSize) {
                discardPolicy.discard();
            }
            TASK_QUEUE.addLast(runnable);
            //å”¤é†’çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹
            TASK_QUEUE.notifyAll();
        }
    }

    public void shutdown() throws InterruptedException {
        //åˆ¤æ–­ä»»åŠ¡é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
        while (!TASK_QUEUE.isEmpty()) {
            Thread.sleep(50);
        }
        int initVal = THREAD_QUEUE.size();
        while (initVal > 0) {
            for (MyThread thread : THREAD_QUEUE) {
                if (thread.getThreadState() == ThreadState.BLOCKED) {
                    thread.close();
                    thread.interrupt();
                    initVal--;
                } else {
                    Thread.sleep(10);
                }
            }
        }
        this.destroy = true;
        System.out.println("My Thread pool is shutdown");
    }

    public boolean isDestroy() {
        return this.destroy;
    }

    private void createThreadQueue() {
        MyThread thread = new MyThread(GROUP, THREAD_PREFIX + (seq++));
        thread.start();
        THREAD_QUEUE.add(thread);
    }


    private enum ThreadState {
        FREE, RUNNING, BLOCKED, DEAD
    }

    public static class DiscardException extends RuntimeException {
        public DiscardException(String message) {
            super(message);
        }
    }

    @FunctionalInterface
    public interface DiscardPolicy {
        void discard() throws DiscardException;
    }

    private static class MyThread extends Thread {
        private volatile ThreadState threadState = ThreadState.FREE;

        public ThreadState getThreadState() {
            return this.threadState;
        }

        public MyThread(ThreadGroup group, String name) {
            super(group, name);
        }

        @Override
        public void run() {
            OUTER:
            while (this.threadState != ThreadState.DEAD) {
                Runnable runnable;
                synchronized (TASK_QUEUE) {
                    while (TASK_QUEUE.isEmpty()) {
                        try {
                            this.threadState = ThreadState.BLOCKED;
                            TASK_QUEUE.wait();
                        } catch (InterruptedException e) {
                            System.out.println(Thread.currentThread().getName() + " is dead");
                            break OUTER;
                        }
                    }
                    runnable = TASK_QUEUE.removeFirst();
                }
                Optional.of(runnable).ifPresent(t -> {
                    this.threadState = ThreadState.RUNNING;
                    t.run();
                    this.threadState = ThreadState.FREE;
                });
            }
        }

        private void close() {
            this.threadState = ThreadState.DEAD;
        }
    }
}

```

- `shutdown`æ–¹æ³•å®ç°

â‘ å…ˆè½®è¯¢ä»»åŠ¡é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼Œä¸ä¸ºç©ºå°±ä¼šè®©`å½“å‰çº¿ç¨‹`ç­‰å¾…`çº¿ç¨‹é˜Ÿåˆ—`çš„çº¿ç¨‹æ‰§è¡Œå®Œæ‰€æœ‰ä»»åŠ¡ã€‚

â‘¡å½“ä»»åŠ¡é˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼Œéå†`çº¿ç¨‹é˜Ÿåˆ—`ï¼Œç„¶åæ‰“æ–­`BLOCK`çš„çº¿ç¨‹å¹¶ä¸”è®¾ç½®ä¸º`DEAD`çŠ¶æ€è·³å‡ºå¾ªç¯ï¼Œå› ä¸º`ä»»åŠ¡é˜Ÿåˆ—`ä¸ºç©º`çº¿ç¨‹é˜Ÿåˆ—`é‡Œé¢çš„çº¿ç¨‹éƒ½ä¼šåœ¨`TASK_QUEUE`ä¸Šé¢`BLOCK`ä½ï¼Œä½†æ˜¯ä¹Ÿå­˜åœ¨ç‰¹æ®Šæƒ…å†µï¼Œå¯èƒ½æŸä¸ªçº¿ç¨‹åˆšæ‹¿åˆ°æœ€åä¸€ä¸ªä»»åŠ¡ï¼Œè¿™ç§æƒ…å†µæˆ‘ä»¬å¯ä»¥ç¨å¾®ç­‰ä¸€ä¸‹ï¼Œç­‰å®ƒ`BLOCK`ï¼Œæ¯•ç«Ÿè¿™æ˜¯ä¸ª`lg(N)-lg(N2)`çš„æ–¹æ³•

â‘¢è®¾ç½®`destory`çŠ¶æ€ä¸ºtrueï¼Œç„¶ååœ¨`submit`çš„æ—¶å€™ä¼šæ ¹æ®è¿™ä¸ªå˜é‡æ¥åˆ¤æ–­æ˜¯å¦å·²ç»é”€æ¯ï¼Œå¦‚æœå·²ç»é”€æ¯å°±ä¼šæŠ›å‡ºä¸€ä¸ª`RunntimeException`

- `æ‹’ç»ç­–ç•¥`å®ç°

è¿™é‡Œå®ç°äº†ä¸€ä¸ªÂ·é»˜è®¤çš„æ‹’ç»ç­–ç•¥ï¼ŒæŠ›å‡ºå¼‚å¸¸ï¼Œåœ¨submitçš„æ—¶å€™åˆ¤æ–­ä»»åŠ¡é˜Ÿåˆ—æ˜¯ä¸æ˜¯æ»¡çš„ï¼Œå¦‚æœæ»¡äº†å°±ç›´æ¥æŠ›å¼‚å¸¸ï¼Œè¿™é‡Œå¦‚æœç”¨è¿™ç§æ–¹å¼æ‹’ç»ï¼Œä¸€ä½†å‡ºç°å¼‚å¸¸`å½“å‰çº¿ç¨‹`å°±ä¼š`ç›´æ¥ç»“æŸ`å¯èƒ½å°±æ— æ³•å…³é—­è¿æ¥æ± ã€‚

#### è‡ªåŠ¨æ‰©å®¹&é—²æ—¶å›æ”¶

```java
public class SimpleThreadPool extends Thread {
    //çº¿ç¨‹æ± å¤§å°
    private int size;
    //çº¿ç¨‹å¤§å°å˜åŒ–å€¼
    private int min;
    private int active;
    private int max;
    //é»˜è®¤å€¼
    private final static int MIN = 4;
    private final static int ACTIVE = 8;
    private final static int MAX = 12;
    //ä»»åŠ¡é˜Ÿåˆ—å¤§å°
    private final int queueSize;

    public int getMin() {
        return min;
    }

    public int getActive() {
        return active;
    }

    public int getMax() {
        return max;
    }

    //çº¿ç¨‹æ± ä¸­çº¿ç¨‹ç¼–å·
    private static volatile int seq = 0;
    //é»˜è®¤ä»»åŠ¡é˜Ÿåˆ—çš„å¤§å°
    private final static int DEFAULT_TASK_QUEUE_SIZE = 2000;

    //çº¿ç¨‹ç»„
    private final static ThreadGroup GROUP = new ThreadGroup("Pool_Group");
    //çº¿ç¨‹åå‰ç¼€
    private final static String THREAD_PREFIX = "SIMPLE_THREAD_POOL-";
    //ä»»åŠ¡é˜Ÿåˆ—
    private final static LinkedList<Runnable> TASK_QUEUE = new LinkedList<>();
    //çº¿ç¨‹é˜Ÿåˆ—
    private final static List<MyThread> THREAD_QUEUE = new ArrayList<>();
    //æ‹’ç»ç­–ç•¥
    private final DiscardPolicy discardPolicy;
    //çº¿ç¨‹æ± æ˜¯å¦é”€æ¯
    private volatile boolean destroy = false;
    //é»˜è®¤çš„æ‹’ç»ç­–ç•¥ï¼ˆæŠ›å¼‚å¸¸ï¼‰
    public final static DiscardPolicy DEFAULT_DISCARD_POLICY = () -> {
        throw new DiscardException("Discard this Task!!!!(Default Policy)");
    };

    public SimpleThreadPool(int min, int active, int max, int queueSize, DiscardPolicy discardPolicy) {
        this.queueSize = queueSize;
        this.discardPolicy = discardPolicy;
        this.min = min;
        this.active = active;
        this.max = max;
        init();
    }

    public SimpleThreadPool() {
        this(MIN, ACTIVE, MAX, DEFAULT_TASK_QUEUE_SIZE, DEFAULT_DISCARD_POLICY);
    }

    //çº¿ç¨‹æ± çš„çº¿ç¨‹ï¼Œç»´æŠ¤æ•´ä¸ªçº¿ç¨‹
    @Override
    public void run() {
        while (!destroy) {
            System.err.printf("Pool#min:%d,active:%d,max:%d,currentSize:%d,taskRemain:%d\n",
                    this.min, this.active, this.max, this.size, TASK_QUEUE.size());
            try {
                Thread.sleep(5000);
                if (TASK_QUEUE.size() > active && size < active) {
                    for (int i = size; i < active; i++) {
                        createThreadQueue();
                    }
                    System.out.println("increment to active success");
                    this.size = active;
                } else if (TASK_QUEUE.size() > max && size < MAX) {
                    for (int i = size; i < max; i++) {
                        createThreadQueue();
                    }
                    System.out.println("increment to max success");
                    this.size = max;
                }
                if (TASK_QUEUE.isEmpty() && size > active) {
                    System.out.println("==================reduce=================");
                    //é˜²æ­¢å¹¶å‘ä¿®æ”¹ï¼Œåœ¨shutdownçš„æ—¶å€™reduce
                    synchronized (THREAD_QUEUE) {
                        int release = size - active;
                        //Itertorå¯ä»¥åœ¨éå†çš„è¿‡ç¨‹ä¸­remove
                        for (Iterator<MyThread> it = THREAD_QUEUE.iterator(); it.hasNext(); ) {
                            if (release <= 0)
                                break;
                            MyThread mt = it.next();
                            //å¦‚æœè¯¥çº¿ç¨‹åœ¨å·¥ä½œå°±ä¸è¦æ‰“æ–­å®ƒ
                            if(mt.getThreadState()==ThreadState.RUNNING){
                                continue;
                            }
                            mt.close();
                            mt.interrupt();
                            it.remove();
                            release--;
                        }
                        this.size = active;
                    }

                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private void init() {
        /*    for (int i = 0; i < size; i++) {
            createThreadQueue();
        }*/
        for (int i = 0; i < this.min; i++) {
            createThreadQueue();
        }
        this.size = min;
        this.start();
    }

    public void submit(Runnable runnable) {
        if (destroy) {
            throw new IllegalStateException("The Pool is shutdown , you can't submit now ! !");
        }
        synchronized (TASK_QUEUE) {
            if (TASK_QUEUE.size() > queueSize) {
                discardPolicy.discard();
            }
            TASK_QUEUE.addLast(runnable);
            //å”¤é†’çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹
            TASK_QUEUE.notifyAll();
        }
    }

    public void shutdown() throws InterruptedException {
        while (!TASK_QUEUE.isEmpty()) {
            Thread.sleep(50);
        }
        int initVal = THREAD_QUEUE.size();
        synchronized (THREAD_QUEUE) {
            while (initVal > 0) {
                for (MyThread thread : THREAD_QUEUE) {
                    if (thread.getThreadState() == ThreadState.BLOCKED) {
                        //è®¾ç½®ä¸ºDEADçŠ¶æ€
                        thread.close();
                        thread.interrupt();
                        initVal--;
                    } else {
                        Thread.sleep(10);
                    }
                }
            }
        }
        this.destroy = true;
        System.out.println("My Thread pool is shutdown");
    }

    public boolean isDestroy() {
        return this.destroy;
    }

    private void createThreadQueue() {
        MyThread thread = new MyThread(GROUP, THREAD_PREFIX + (seq++));
        thread.start();
        THREAD_QUEUE.add(thread);
    }


    private enum ThreadState {
        FREE, RUNNING, BLOCKED, DEAD
    }

    public static class DiscardException extends RuntimeException {
        public DiscardException(String message) {
            super(message);
        }
    }

    @FunctionalInterface
    public interface DiscardPolicy {
        void discard() throws DiscardException;
    }

    private static class MyThread extends Thread {
        private volatile ThreadState threadState = ThreadState.FREE;

        public ThreadState getThreadState() {
            return this.threadState;
        }

        public MyThread(ThreadGroup group, String name) {
            super(group, name);
        }

        @Override
        public void run() {
            OUTER:
            while (this.threadState != ThreadState.DEAD) {
                Runnable runnable;
                synchronized (TASK_QUEUE) {
                    while (TASK_QUEUE.isEmpty()) {
                        try {
                            this.threadState = ThreadState.BLOCKED;
                            TASK_QUEUE.wait();
                        } catch (InterruptedException e) {
                            System.out.println(Thread.currentThread().getName() + " is dead");
                            break OUTER;
                        }
                    }
                    runnable = TASK_QUEUE.removeFirst();
                }
                Optional.of(runnable).ifPresent(t -> {
                    this.threadState = ThreadState.RUNNING;
                    t.run();
                    this.threadState = ThreadState.FREE;
                });
            }
        }

        private void close() {
            this.threadState = ThreadState.DEAD;
        }
    }
}
```

ç›¸æ¯”ä¸Šé¢å›ºå®šçš„sizeè¿™ä¸ªç‰ˆæœ¬

â‘  å¢åŠ äº†ä¸‰ä¸ªå­—æ®µç”¨äºåŠ¨æ€çš„æ‰©å®¹ï¼Œå› ä¸ºéœ€è¦ç®¡ç†è¿™äº›çº¿ç¨‹ï¼Œæ‰€ä»¥å°†æ•´ä¸ªçº¿ç¨‹æ± ä¹Ÿç»§æ‰¿äº†`Thread`å¹¶å®ç°äº†runæ–¹æ³•ï¼Œä¸»è¦å°±æ˜¯åˆ¤æ–­`TASK_QUEUE.size() > active && size < active`å½“å‰ä»»åŠ¡é˜Ÿåˆ—ä»»åŠ¡å¤šäº`active`å¹¶ä¸”å½“å‰çº¿ç¨‹é˜Ÿåˆ—çº¿ç¨‹æ•°å°äº`active`ï¼Œå°±å¯ä»¥æ‰©å®¹åˆ°activeï¼ŒmaxåŒç†

â‘¡`TASK_QUEUE.isEmpty() && size > active` é—²æ—¶å›æ”¶ï¼Œä»»åŠ¡é˜Ÿåˆ—æ²¡æœ‰ä»»åŠ¡ï¼Œä½†æ˜¯çº¿ç¨‹é˜Ÿåˆ—çº¿ç¨‹è¿˜å¾ˆå¤šï¼Œæµªè´¹äº†èµ„æºï¼Œæ‰€ä»¥éœ€è¦`reduce`ä¸€äº›ç©ºé—²çš„çº¿ç¨‹ã€‚è¿™é‡Œæœ‰ä¸¤ä¸ªå°ç»†èŠ‚ï¼Œ1.åœ¨reduceå’Œshutdownçš„æ—¶å€™éœ€è¦åŒæ­¥`çº¿ç¨‹é˜Ÿåˆ—`ä¸ç„¶åœ¨`reduce`çš„æ—¶å€™`shutdown`ä¼šäº§ç”Ÿ`å¹¶å‘ä¿®æ”¹å¼‚å¸¸`ï¼ˆä¸€ä¸ªåœ¨éå†ï¼Œä¸€ä¸ªåœ¨removeï¼‰ã€‚

### æµ‹è¯•çº¿ç¨‹æ± 

```java
public class ThreadPoolTest {
    public static void main(String[] args) throws InterruptedException {
        SimpleThreadPool threadPool= new SimpleThreadPool();
        IntStream.rangeClosed(0, 40)
                .forEach(i -> {
                    threadPool.submit(() -> {
                        System.out.println("The task " + i + "  runnable by thread " + Thread.currentThread().getName() + " start");
                        try {
                            Thread.sleep(5000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println("The task " + i + "  runnable by thread " + Thread.currentThread().getName() + " end");
                    });
                    System.out.println("submit " + i);
                });
        threadPool.shutdown();
    }
}
```

## å‚è€ƒèµ„æ–™

- ã€ŠJavaå¤šçº¿ç¨‹ç¼–ç¨‹å®æˆ˜æŒ‡å—ã€‹ 
- [å¹¶å‘ç¼–ç¨‹ç½‘](http://ifeve.com)
- [Javaè¯­è¨€è§„èŒƒ](https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.2.4)

