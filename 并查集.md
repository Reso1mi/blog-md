---
title:
  并查集
tags:
  [算法,数据结构]
categories:
	[数据结构]
cover: http://static.imlgw.top/blog/20200101/SdfeawuEf9Qz.png?imageslim
---

## 并查集

并查集是一种奇怪的树结构，常用于处理一些集合的合并和查询问题，主要有两种操作：合并和查找

### UF接口

```java
public interface UF{
    int getSize(); //获取并查集的大小
    boolean isConnected(int p,int q); //是否连接
    void unionElement(int p,int q); //合并两个集合
}
```

### UnionFind1-QuickFind

按照朴素的思路写出的并查集

```java
public class UnionFind1 implements UF{

    private int[] id; //集合ids

    public UnionFind1(int size){
        id=new int[size];
        for (int i=0;i<size;i++) {
            id[i]=i;
        }
    }

    public int getSize(){
        return id.length;
    }

    //p所属的集合ID
    private int find(int p){
        if (p<0 && p>=id.length) {
            throw new IllegalArgumentException("p is out....");
        }
        return id[p];
    }
    
    //判断集合ID是不是一样的
    public boolean isConnected(int p,int q){
        return find(q)==find(p);
    }

    public void unionElement(int p,int q){
        int pID=find(p);
        int qID=find(q);
        if (qID==pID) {
            return;
        }
        for (int i=0;i<id.length;i++) {
            if (id[i]==qID) {
                id[i]=pID;
            }
        }
    }
}
```

初始化的时候每个元素都是不同的集合ID

`find`操作会返回他们所属集合ID，时间复杂度`O(1)`

`isConnected`会判断两个元素的集合ID是不是相同的，时间复杂度也是`O(1)`

而`unionElement` 合并操作就是遍历整个集合，将集合ID等于其中一个的改成另一个，时间复杂度`O(N)`

> 这种方式属于快速查找，但是合并的效率太低了，我们还可以继续优化下

### UnionFind2-QuickUnion

这一次我们不记录每个元素所属的集合ID，我们记录每个元素的父元素的ID，根节点一样的元素就是一个集合，这样就形成了一颗奇怪的树，由子节点指向父节点的树（森林）

```java
public class UnionFind2 implements UF{

    private int[] parent; //父ID

    public UnionFind2(int size){
        parent=new int[size];
        for (int i=0;i<size;i++) {
            parent[i]=i;
        }
    }

    public int getSize(){
        return parent.length;
    }

    //p所属的集合ID
    private int find(int index){
        if (index<0 && index>=parent.length) {
            throw new IllegalArgumentException("index is out....");
        }
        while(parent[index]!=index){
            index=parent[index];
        }
        return index;
    }
    
    //判断集合ID是不是一样的
    public boolean isConnected(int p,int q){
        return find(q)==find(p);
    }

    public void unionElement(int p,int q){
        int pID=find(p);
        int qID=find(q);
        if (qID==pID) {
            return;
        }
        parent[pID]=qID;
    }
}
```

初始化的时候每个元素的父节点都指向自己

`find`操作的时候就不停的向上爬，找到每个元素的根节点，就是它的集合ID，时间复杂度就是`O(h)` h是树的高度，注意这里并不是`logN`，因为这课树并一定是一棵二叉树

`isConnected` 和上面一样，判断两个元素的根节点时候一样就ok

`unionElement` 合并两个元素的集合，我们只需要将其中一个`parentID`变为另一个的`parentID`就Ok了，时间复杂度`O(hq)+O(hp)` (hp，hq代表p和q形成的树的高度)

> 相比上面的UnionFInd1我们牺牲了一点查找的效率获得了更高的合并效率，但是仍然还有可以优化的点，我们这里在合并两个集合的时候，并没有考虑两颗树的形状，直接将一颗树加在了另一颗的后面，而这样很有可能会增加合并后的树的高度，甚至可能会形成一个链表的结构，这将极大的影响我们的时间复杂度，所以我们可以考虑更好的合并方式

![mark](http://static.imlgw.top/blog/20200101/ifSkJmMWNB2U.png?imageslim)

### UnionFind3-size优化

这里我们添加一个sz数组用来记录每个集合的元素个数

```java
public class UnionFind3 implements UF{

    private int[] parent; //父ID

    private int[] sz; //记录每颗树的节点数量

    public UnionFind3(int size){
        parent=new int[size];
        sz=new int[size];
        for (int i=0;i<size;i++) {
            parent[i]=i;
            sz[i]=1;
        }
    }

    public int getSize(){
        return parent.length;
    }

    //p所属的集合ID
    private int find(int index){
        if (index<0 && index>=parent.length) {
            throw new IllegalArgumentException("index is out....");
        }
        while(parent[index]!=index){
            index=parent[index];
        }
        return index;
    }
    
    //判断集合ID是不是一样的
    public boolean isConnected(int p,int q){
        return find(q)==find(p);
    }

    public void unionElement(int p,int q){
        int pID=find(p);
        int qID=find(q);
        if (qID==pID) {
            return;
        }
        if (sz[pID]>sz[qID]) {
            parent[qID]=pID;
            sz[pID]+=sz[qID];    
        }else{
            parent[pID]=qID;
            sz[qID]+=sz[pID];
        }
    }
}
```

初始化的时候额外的将每个元素的sz置为1

`find`操作和`isConnected`没有变化

`unionElement` 的时候我们不在是盲目的随意合并，而是将size小的集合加在size大的集合下

![mark](http://static.imlgw.top/blog/20200101/ifSkJmMWNB2U.png?imageslim)

类似这样的情况下就不会将1接在5下面，而是将5接在1下面，这样合并后的集合的高度就不会增大

> 但是根据size判断一定能准确判断么？很显然是不行的

![mark](http://static.imlgw.top/blog/20200101/SdfeawuEf9Qz.png?imageslim)

类似这样的，如果按照之前的按照size合并的方案可能反而会导致树的高度增加，所以更加合理的方案应该是根据树的高度来合并

### UnionFind4-hight优化

```java
public class UnionFind4 implements UF{

    private int[] parent; //父ID

    private int[] hight; //每个集合形成的树的高度

    public UnionFind4(int size){
        parent=new int[size];
        hight=new int[size];
        for (int i=0;i<size;i++) {
            parent[i]=i;
            hight[i]=1;
        }
    }

    public int getSize(){
        return parent.length;
    }

    //p所属的集合ID
    private int find(int index){
        if (index<0 && index>=parent.length) {
            throw new IllegalArgumentException("index is out....");
        }
        while(parent[index]!=index){
            index=parent[index];
        }
        return index;
    }
    
    //判断集合ID是不是一样的
    public boolean isConnected(int p,int q){
        return find(q)==find(p);
    }

    public void unionElement(int p,int q){
        int pID=find(p);
        int qID=find(q);
        if (qID==pID) {
            return;
        }
        if (hight[pID]>hight[qID]) {
            parent[qID]=pID;    
        }else if(hight[pID]<hight[qID]){
            parent[pID]=qID;
        }else{ //高度相等情况,才会增大树的高度
            parent[pID]=qID; 
            hight[qID]++;
        }
    }
}
```

初始化的时候仍然将每个元素的高度设置为1

合并的时候我们根据树的高度来合并，将高度小的集合添加到高度大的集合上，这样整体的高度并不会变化，仍然是高度较大的集合的高度，只有在两颗树的高度相同的时候才会使集合高度增加，这个时候就无所谓谁添加到谁上了

> 回头想一想，其实我们查找或者合并的时候并不会去关系每个元素的父节点又或者爷节点是啥，我们只关心的是这个元素的祖宗节点是啥，也就是根节点是啥，也就是我们希望每个集合的高度越小越好

![mark](http://static.imlgw.top/blog/20200101/D84lWwYGlVag.png?imageslim)

### UnionFind5-路径压缩

在find过程中增加了路径压缩的功能

```java
public class UnionFind5 implements UF{

    private int[] parent; //父ID

    private int[] rank;

    public UnionFind5(int size){
        parent=new int[size];
        rank=new int[size];
        for (int i=0;i<size;i++) {
            parent[i]=i;
            rank[i]=1;
        }
    }

    public int getSize(){
        return parent.length;
    }

    //p所属的集合ID
    private int find(int index){
        if (index<0 && index>=parent.length) {
            throw new IllegalArgumentException("index is out....");
        }
        while(parent[index]!=index){
            parent[index]=parent[parent[index]]; //路径压缩
            index=parent[index];
        }
        return index;
    }
	
    //递归的方式进行路径压缩，可以压得更低
    private int find2(int index){
        if (index<0 && index>=parent.length) {
            throw new IllegalArgumentException("index is out....");
        }
        if(parent[index]!=index){
            parent[index]=find2(parent[index]);
        }
        return parent[index];
    }
    
    //判断集合ID是不是一样的
    public boolean isConnected(int p,int q){
        return find(q)==find(p);
    }

    public void unionElement(int p,int q){
        int pID=find(p);
        int qID=find(q);
        if (qID==pID) {
            return;
        }
        if (rank[pID]>rank[qID]) {
            parent[qID]=pID;    
        }else if(rank[pID]<rank[qID]){
            parent[pID]=qID;
        }else{ //高度相等情况,才会增大树的Rank
            parent[pID]=qID; 
            rank[qID]++;
        }
    }
}
```

find操作本身就是一个向上遍历的过程，所以我们可以直接再find得过程中去进行路径的压缩

核心的语句就是 `parent[index]=parent[parent[index]];`

如果父节点不是要找的根节点就将父节点设置为父节点的父节点

当然这里还有一种压缩的方式，可以将树压缩的更短，也就是上面的`find2`，核心语句就是

 `parent[index]=find2(parent[index])` 

![mark](http://static.imlgw.top/blog/20200101/D84lWwYGlVag.png?imageslim)

如果是这样的树执行 `find2(5)` 可以直接将树压缩成左边的样子，而`find1(5)` 并不能一次就压缩成这样，两者各有优缺点，这里不过多阐述

> 细心的朋友肯定发现了，我这里将`hight`改成了`rank`，为什么要改成rank?
>
> 其实原因很简单，在加入了路径压缩后，这里的hight不再能表示高度的含义，所以我们改成了Rank
>
> 那我们为什么不继续维护这个高度了？这样不是就无法准确的判断如何合并了嘛？
>
> 其实这里如果想要继续维护这个树的高度是一种不太明智的选择，成本太大了，难以维护，并不是简单的`--` 就可以完成的，会有很多的情况，所以我们索性直接将其改成Rank作为一个参考量，表示这个集合的排名，其实仔细想一想，我们进行路径压缩带来的优化明显会大于维护hight带来的优化

### 时间复杂度

这里经过科学家们的计算证明得到最终的时间复杂度是 `O(log*N)`我也是第一次听说这个复杂度，

![mark](http://static.imlgw.top/blog/20200101/iXPijTwciz0b.png?imageslim)

**迭代对数**

| n                | lg* n |
| ---------------- | ----- |
| (−∞, 1]          | 0     |
| (1, 2]           | 1     |
| (2, 4]           | 2     |
| (4, 16]          | 3     |
| (16, 65536]      | 4     |
| (65536, 2^65536] | 5     |

可以看到，时间复杂度是相当低，可以近似的认为就是一个`O(1)` 常数的复杂度

## 练手例题

### [547. 朋友圈](https://leetcode-cn.com/problems/friend-circles/)

班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。

给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果`M[i][j] = 1`，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。

**示例 1:**

```java
输入: 
[[1,1,0],
 [1,1,0],
 [0,0,1]]
输出: 2 
说明：已知学生0和学生1互为朋友，他们在一个朋友圈。
第2个学生自己在一个朋友圈。所以返回2。
```

**示例 2:**

```java
输入: 
[[1,1,0],
 [1,1,1],
 [0,1,1]]
输出: 1
说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。
```

**注意：**

1. N 在`[1,200]`的范围内。
2. 对于所有学生，有`M[i][i] = 1`。
3. 如果有`M[i][j] = 1`，则有`M[j][i] = 1`。

**解法二**

这题很久之前做过 [LeetCode回溯&递归](http://imlgw.top/2019/10/10/leetcode-hui-su/#547-%E6%9C%8B%E5%8F%8B%E5%9C%88) 当时DFS做的，其实这题应该属于最经典的并查集的题目了

```java
private int[] parent; //父ID

private int[] rank;

//p所属的集合ID
private int find(int index){
    if (index<0 && index>=parent.length) {
        throw new IllegalArgumentException("index is out....");
    }
    while(parent[index]!=index){
        parent[index]=parent[parent[index]];
        index=parent[index];
    }
    return index;
}

public void unionElement(int p,int q){
    int pID=find(p);
    int qID=find(q);
    if (qID==pID) {
        return;
    }
    if (rank[pID]>rank[qID]) {
        parent[qID]=pID;    
    }else if(rank[pID]<rank[qID]){
        parent[pID]=qID;
    }else{ //高度相等情况,才会增大树的高度
        parent[pID]=qID; 
        rank[qID]++;
    }
}

public int findCircleNum(int[][] M) {
    parent=new int[M.length];
    rank=new int[M.length];
    //初始化
    for (int i=0;i<M.length;i++) {
        parent[i]=i;
        rank[i]=1;
    }
    //union
    for (int i=0;i<M.length;i++) {
        for (int j=0;j<M.length;j++) {
            if (M[i][j]==1) {
                unionElement(i,j);
            }
        }
    }
    int res=0;
    for (int i=0;i<parent.length;i++) {
        if (parent[i]==i) {
            res++;
        }
    }
    return res;
}
```

代码还是很简单的，合并之后统计一下数量就ok了

### [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

给定一个未排序的整数数组，找出最长连续序列的长度。

要求算法的时间复杂度为 `O(n)`。

**示例:**

```java
输入: [100, 4, 200, 1, 3, 2]
输出: 4
解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**并查集解法**

```java
//并查集
HashMap<Integer,Integer> parent;

HashMap<Integer,Integer> size;

int max=1;

public int find(int index){
    while(parent.get(index)!=index){
        //parent[index]=parent[parent[index]];
        parent.put(index,parent.get(index));
        index=parent.get(index);
    }
    return index;
}

public void union(int p,int q){
    int pID=find(p);
    int qID=find(q);
    if (pID==qID) {
        return;
    }
    int pSize=size.get(pID);
    int qSize=size.get(qID);
    if (pSize > qSize) {
        //parent[qID]=pID;
        parent.put(qID,pID);
        //size[pID]+=size[qID];
        size.put(pID,pSize+qSize);
    }else{
        //parent[pID]=qID;
        parent.put(pID,qID);
        //size[qID]+=size[pID];
        size.put(qID,pSize+qSize);
    }
    max=Math.max(max,pSize+qSize); //统计最大值
}

public void initUnionFind(int[]nums){
    parent=new HashMap<>();
    size=new HashMap<>();
    for (int i=0;i<nums.length;i++) {
        parent.put(nums[i],nums[i]);
        size.put(nums[i],1);
    }
}

public int longestConsecutive(int[] nums) {
    if (nums ==null || nums.length<=0) {
        return 0;
    }
    HashSet<Integer> set=new HashSet();
    for (int i=0;i<nums.length;i++) {
        set.add(nums[i]);
    }
    initUnionFind(nums);
    for (int i=0;i<nums.length;i++) {
        if (set.contains(nums[i]-1)) { //判断-1或者+1都可以
            union(nums[i],nums[i]-1);
        }
    }
    return max;
}
```

这里用并查集其实并不是最优解，直接循环用HashSet感觉会更好更简洁  [详见 LeetCode查找](http://imlgw.top/2019/09/15/leetcode-cha-zhao/) 不过熟悉一下并查集还是不错的，这里因为是根据num的数值判断的，code所以用数组索引合并是行不通的，需要改成Hash表

### [5309. 连通网络的操作次数](https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/)

用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。

网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。

给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。 

**示例 1：**

![leet.png](https://img04.sogoucdn.com/app/a/100520146/a56899d8db652c4b31c86b856bd86477)

```java
输入：n = 4, connections = [[0,1],[0,2],[1,2]]
输出：1
解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上
```

**示例 2：**

![leetcode.png](https://img02.sogoucdn.com/app/a/100520146/d7f2256f0eb95f9840ba3132e94f2c26)

```java
输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]
输出：2
```

**示例 3：**

```java
输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]
输出：-1
解释：线缆数量不足。
```


**示例 4：**

```java
输入：n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]
输出：0
```

**提示：**

- 1 <= n <= 10^5
- 1 <= connections.length <= min(n*(n-1)/2, 10^5)
- connections[i].length == 2
- 0 <= connections[i][0], connections[i][1] < n
- connections[i][0] != connections[i][1]
- 没有重复的连接。
- 两台计算机不会通过多条线缆连接。

**解法一**

1.12周赛的第三题，挺有意思的，当时想了一会儿，然后就直接想到了并查集

```java
private int[] parent; //父ID

private int[] rank;

//p所属的集合ID
private int find(int index){
    if (index<0 && index>=parent.length) {
        throw new IllegalArgumentException("index is out....");
    }
    while(parent[index]!=index){
        parent[index]=parent[parent[index]];
        index=parent[index];
    }
    return index;
}

public void union(int p,int q){
    int pID=find(p);
    int qID=find(q);
    if (qID==pID) {
        return;
    }
    if (rank[pID]>rank[qID]) {
        parent[qID]=pID;    
    }else if(rank[pID]<rank[qID]){
        parent[pID]=qID;
    }else{ //高度相等情况,才会增大树的高度
        parent[pID]=qID; 
        rank[qID]++;
    }
}

//判断集合ID是不是一样的
public boolean isConnected(int p,int q){
    return find(q)==find(p);
}

public void initUF(int n){
    parent=new int[n];
    rank=new int[n];
    for (int i=0;i<n;i++) {
        parent[i]=i;
        rank[i]=1;
    }
}

public int makeConnected(int n, int[][] connections) {
    initUF(n);
    int more=0;
    for (int i=0;i<connections.length;i++) {
        if (isConnected(connections[i][0],connections[i][1])) {
            more++; //多出来的边个数
        }else{
            union(connections[i][0],connections[i][1]);
        }
    }
    int count=0;
    for (int i=0;i<n;i++) {
        if (parent[i]==i) {
            count++; //集合个数
        }
    }
    return count-1<=more?count-1:-1;
}
```

核心思路就是将元素合并，然后中间求出多出的边，最后判断多出来的边能不能将所有的集合聚合成一个大集合，也就是`count-1<=more`的时候才可以联通，否则就无法联通

###  未完待续

其实之前做的一些题都可以用并查集做，像[岛屿数量]()，[岛屿最大面积]()啥的，这里就不多写了，都差不多