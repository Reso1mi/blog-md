---
title: 
   力扣42双周赛(T3,T4)
tags: 
  [LeetCode,动态规划]
categories:
	[算法]
---

## [1702. 修改后的最大二进制字符串](https://leetcode-cn.com/problems/maximum-binary-string-after-change/)

Difficulty: **中等**


给你一个二进制字符串 `binary` ，它仅有 `0` 或者 `1` 组成。你可以使用下面的操作任意次对它进行修改：

*   操作 1 ：如果二进制串包含子字符串 "00" ，你可以用 "10" 将其替换。
    *   比方说， "00010" -> "10010"
*   操作 2 ：如果二进制串包含子字符串 "10" ，你可以用 "01" 将其替换。
    *   比方说， "00010" -> "00001"

请你返回执行上述操作任意次以后能得到的 **最大二进制字符串** 。如果二进制字符串 `x` 对应的十进制数字大于二进制字符串 `y` 对应的十进制数字，那么我们称二进制字符串`x`大于二进制字符串`y`。

**示例 1：**

```c
输入：binary = "000110"
输出："111011"
解释：一个可行的转换为：
"000110" -> "000101" 
"000101" -> "100101" 
"100101" -> "110101" 
"110101" -> "110011" 
"110011" -> "111011"
```

**示例 2：**

```c
输入：binary = "01"
输出："01"
解释："01" 没办法进行任何转换。
```

**提示：**

*   1 <= binary.length <= 10<sup>5</sup>
*   `binary` 仅包含 '0' 和 '1' 。


### 解法一

因为是补题，之前在群里有看见讨论，大致的提到了一些，所以这里很快就想到了贪心的思路。首先01是无法继续变化的，10是可以变成01的，而开头连续的1肯定是不需要再变化的，变化只会使得结果变小，所以我们可以将除了开头连续的1以外的所有的1都转换到最后（一定是可以的，因为10可以变成01），然后再将中间的00都转换成10最后剩下的就只有中间的一个0，这样就使得结果最大了。最终的结果就是1111...0...111类似的形式
```java
​public class MaximumBinaryString {
    //100101100 --> 100000111 --> 111110111
1   //1100 --> 1110
    public String maximumBinaryString(String binary) {
        int n = binary.length();
        int cnt = 0;
        int i = 0;
        while (i < n && binary.charAt(i) == '1') i++;
        if (i==n) return binary;
        while (i < n) {
            if (binary.charAt(i) == '1') cnt++;
            i++;
        }
        StringBuilder sb = new StringBuilder();
        for (int j = 0; j < n-cnt-1; j++) {
            sb.append("1");
        }
        sb.append("0");
        for (int j = 0; j < cnt; j++) {
            sb.append("1");
        }
        return sb.toString();
    }
}
```

## [1703. 得到连续K个1的最少相邻交换次数](https://leetcode-cn.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones/)

Difficulty: **困难**


给你一个整数数组 `nums` 和一个整数 `k` 。 `nums` 仅包含 `0` 和 `1` 。每一次移动，你可以选择 **相邻** 两个数字并将它们交换。

请你返回使 `nums` 中包含 `k` 个 **连续 **`1` 的 **最少** 交换次数。

**示例 1：**

```c
输入：nums = [1,0,0,1,0,1], k = 2
输出：1
解释：在第一次操作时，nums 可以变成 [1,0,0,0,1,1] 得到连续两个 1 。
```

**示例 2：**

```c
输入：nums = [1,0,0,0,0,0,1,1], k = 3
输出：5
解释：通过 5 次操作，最左边的 1 可以移到右边直到 nums 变为 [0,0,0,0,0,1,1,1] 。
```

**示例 3：**

```c
输入：nums = [1,1,0,1], k = 2
输出：0
解释：nums 已经有连续 2 个 1 了。
```

**提示：**

*   1 <= nums.length <= 10<sup>5</sup>
*   `nums[i]` 要么是 `0` ，要么是 `1` 。
*   1 <= k <= sum(nums)


### 解法一
我们要把k个1聚拢在一起，我们设定原始位置为A<sub>0</sub> ~ A<sub>k-1</sub>，聚集后的位置为 X, X+1, X+2...., X+k-1。推导过程如下图：
![](https://i.loli.net/2021/01/10/bUVJps1NOtrfE3c.png)

（Latex在学了在学了😂）
通过上面的通项公式我们就可以在窗口滑动的时候O(1)的求出窗口内的结果
```java
​import java.util.*;
import java.io.*;

/*
1.    得到连续 K 个 1 的最少相邻交换次数
给你一个整数数组 nums 和一个整数 k 。 nums 仅包含 0 和 1 。每一次移动你可以选择 相邻 两个数字并将它们交换。
请你返回使 nums 中包含 k 个 连续 1 的 最少 交换次数。
 */

class Solution {
    public int minMoves(int[] nums, int k) {
        int n = nums.lengh;
        // int[] w = new int[k];
        List<Integer> lis = new ArrayList<>();
        int x = 0;
        for (int i = 0; i < n; i++) {
            if (nums[i]==1) {
                lis.add(i-x);
                x++;
            }
        }
        int[] w = lis.stream().mapToInt(Integer::valueOf).toArray();
        int m = w.length;
        int[] sum = new int[m+1];
        for (int i = 1; i <= m; i++) {
            sum[i] = sum[i-1] + w[i-1];
        }
        //sum[i]: [0,i-1]
        int res = Integer.MAX_VALUE;
        int left = 0;
        for (int right = k-1; right < m; right++) {
            int mid = left+(right-left)/2; //左中位数
            res = Math.min(res, w[mid]*(2*mid-left-right)-(sum[mid]-sum[left])+(sum[right+1]-sum[mid+1]));
            left++;
        }
        return res;
    }
}
```
这里其实有一个[小的问题](https://leetcode-cn.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones/solution/de-dao-lian-xu-k-ge-1-de-zui-shao-xiang-lpa9i/724362)，就是窗口滑动的时候，其实我们一直是用的最开始的预处理的值，也就是A<sub>0</sub>，A<sub>1</sub>-1，A<sub>2</sub>-2，...，A<sub>n</sub>-n，那么我们滑窗的时候需要重新计算成A<sub>1</sub>，A<sub>2</sub>-1，A<sub>3</sub>-2，...，A<sub>n</sub>-(n-1)，吗？

其实并不需要，这里重置本质上就是原来的窗口**整体向右**移动了一步，而我们求的是窗口内元素于中位数差值的和，对结果的计算并没有影响。